<!--
author: Melanie Baur and further professors and students of HFT Stuttgart, contact: melanie.baur@hft-stuttgart.de
language: de
version: 0.2.0
narrator: Deutsch Female
mode: Textbook

comment: Vorlesung Programmieren 1 an der HFT Stuttgart

import: https://raw.githubusercontent.com/liascript/CodeRunner/master/README.md

-->
# Programmieren 1 in Java
<article>
Dieses Online-Buch wird entwickelt an der Hochschule für Technik Stuttgart und dient der Einführung in die Programmierung mit Java zunächst in den Studiengängen Informatik und Wirtschaftsinformatik im 1. Semester. Es werden somit keine Vorkenntnisse im Programmieren vorausgesetzt. Das Buch befindet sich gerade im Aufbau und wird laufend ergänzt und verbessert.

Als Arbeitsweise wird für die Teilnehmenden der oben genannten Vorlesungen vorgeschlagen, jede Woche ein Kapitel durchzuarbeiten inkl. der zur Verfügung stehenden Programmieraufgaben. Der geschätze Zeitaufwand beträgt ohne Vorkenntnisse pro Woche 16 Stunden. Hiervon werden 6 Stunden an der Hochschule erbracht, ein:e Professor:in und/oder ein:e Assistent:in stehen hierbei für Fragen zur Verfügung. 10 Stunden sollen selbständig absolviert werden.

Lesen Sie gerne ein "echtes" Buch? So empfehlen wir die Lektüre von Philipp Ackermann: Schrödinger programmiert Java, Rheinwerk. Sie finden dieses Buch als eBook in der HFT Bibliothek.

Die wichtigsten Informationen finden Sie aber in diesem Online-Buch. Dieses besteht nicht nur aus Text, sondern auch aus Links zu externen Webseiten. Für diese übernehmen wir keinerlei Haftung. Weiterhin gibt es natürlich viele Code-Beispiele. Diese können Sie direkt im Online-Buch ausführen. 

Zum Beispiel ist das folgende ein Programm-Code, bei dem etwas auf der Konsole ausgegeben wird.

```java
class HalloWelt{
    public static void main(String args[]){
        System.out.println("Hallo Welt");
    }
}
```
@LIA.java(HalloWelt)

Klicken Sie nun auf </> im kleinen Kreis unter der Code-Zeile, so wird der Code ausgeführt und Sie sehen im schwarzen Kästchen, das dann erscheint, das Ergebnis.

</article>

Natürlich sollen Sie nicht nur lesen, sondern insbesondere auch viel selbst machen. Hier kommt die erste Aufgabe.

**Aufgabe:**
Geben Sie nun statt "Hallo Welt" einen anderen Text zwischen den Anführungszeichen ein. Führen Sie den Code erneut aus. Was fällt Ihnen auf?

Auf der rechten Seiten unterhalb des Codes, können Sie nun mit den Pfeilen zwischen den verschiedenen Codes hin- und herwechseln. Gehen Sie mit dem Pfeil nach links zurück auf den ursprünglichen Code und dann mit dem Pfeil nach rechts wieder zu Ihrem neuen Code.


**Übungen:**
Um viel zu üben, denn das ist das wichtigste beim Programmieren, werden [hier](https://speiser.hft-pages.io/programmieraufgaben/2024-ss-pro-1/) zu jedem Kapitel Übungen bereit gestellt. Sie werden im Laufe des Buchs immer wieder zu diesen Übungen aufgefordert. Führen Sie die Aufgaben gewissenhaft aus. Bei Problemen fragen Sie einfach in der nächsten Mentoringstunde. 



## Einführung 
Eine Programmiersprache zu lernen, ist unabdingbare Voraussetzung für eine Tätigkeit in der Informatik, z.B. als Entwickler, Projektleiter, Softwarearchitekt, denn die Computer führen exakt den Code aus, den sie vorgesetzt bekommen und die Compiler übersetzen genau das was im Programmtext steht in Maschinencode. 

Sie als Programmierer:

* Analysieren Probleme
* Überlegen sich Lösungen
* Übersetzen Lösungen in Programmtext
Der Computer ist nicht kreativ und findet keine Lösungen. Dafür gibt es die glorreiche Tätigkeit des Programmierens.

Um dies zu können, müssen Sie viel üben:

* Kennen Sie einen Trainer der Bundesliga, der nicht Profi-Fußballer war? 
* Haben Sie Schwimmen oder Radfahren aus Büchern erlernt? 
* Sind Sie zur praktischen Fahrprüfung erstmals Auto gefahren?
* Wie viele Jahre hat ein Musiker vor dem ersten Klavierkonzert geübt?

Was könnte Beispiele für kleine Programme sein?

* Zwei Zahlen addieren
* Eine Zahl abspeichern
* Eine Zahl laden
* Zwei Zahlen miteinander vergleichen

Das können Sie sicherlich auch, aber Computer können das:

* Sehr schnell: Milliarden von Operationen pro Sekunde
* Sehr genau: Milliarden von Zahlen speichern und exakt so wieder abrufen

Sie lernen zunächst, was Code und was ein Programm ist. Am Ende des Kapitels werden Sie Ihr erstes eigenes Programm in der Programmiersprache Java schreiben und ausführen.



### Was ist Code?
* Code ist eine Reihe von Anweisungen,
* Jede Anweisung beschreibt, welche Operation (z.B. Addition) der Computer mit welchen Operanden (z.B. 5 und 3) ausführen soll
* Der Computer führt eine Anweisung nach der anderen aus

Programme bestehen nun aus Millionen von Anweisungen. Die Anweisungen sind wiederum Zahlen - hier als Hexadezimal-codierter x86-Code (erstellt mit [godbolt.org](https://godbolt.org/z/WYorj7EG5)):

```
55 48 89 e5
89 7d fc 8b
45 fc 0f c0
5d c3
```
    
So zu entwickeln ist sehr kompliziert und fehleranfällig, also gibt es ein Abstraktionsniveau höher Assembler - menschenmerkbare Abkürzungen für die Befehle und Hilfe bei der Berechnung von Speicheradressen, wo Daten abgespeichert sind, z.B.:

```
push   rbp
 mov    rbp,rsp
 mov    DWORD PTR [rbp-0x4],edi
 mov    eax,DWORD PTR [rbp-0x4]
 imul   eax,eax
 pop    rbp
 ret    
main:
 push   rbp
 mov    rbp,rsp
 mov    eax,0x0
 pop    rbp
 ret  
```

Auch dies ist noch recht aufwändig - und zudem noch an eine konkrete Prozessorarchitektur gebunden. Als nächstes Abstraktionsniveau kann man dann eine höhere Programmiersprache nehmen, z.B.:

```
int square(int num) {
    return num * num;
}
```

Wir nutzen in unserer Vorlesung Java als Programmiersprache. Im Hintergrund gibt es einen Compiler, der Java in Maschinensprache übersetzt. Die Maschinensprache wird auf unseren Wunsch hin vom Betriebssystem geladen und dann zur Ausführung gebracht. 
Bei Java gibt es noch die Besonderheit, dass es eine Art virtuelle Maschinensprache nutzt, die unabhängig von der genutzten Prozessorarchitektur ist und erst zur Laufzeit von einer weiteren Programmkomponente in die konkrete Maschinensprache übersetzt wird. 
Aber hierzu später mehr


**Welcher Code wird ausgeführt?**

Das Betriebssystem startet den binären Code bei der ersten Anweisung - aber wo ist das in unserem Code der höheren Programmiersprache?

Im allgemeinen Java-Programm: die Main-Methode der Hauptklasse: 

```
public static void main(String[] args) {
}
```


### Was ist Programmieren?
Unter Programmieren versteht man das Erstellen von Anweisungen für eine Maschine. Dies hat historisch eine viel längere Geschichte, als Sie wahrscheinlich vermuten. Besuchen Sie diese [Seite](https://www.cs101.com/) und überzeugen Sie sich selbst. 

Im Rahmen der nächsten zwei Semester werden Sie nun folgendes Lernen: 

* Programmieren 1: Erwerb der Fähigkeit, ein (mittelgroßes) Java-Programm zu schreiben
* Programmieren 2: Erweiterung um die „Kommunikation mit der Außenwelt“ und Einführung in die Web-Programmierung

Ein Programm ist vergleichbar mit einem Kochrezept:
Ziel ist es einen bzw. mehrere fertige Pfannkuchen aus verschiedenen einzelnen Zutaten zu kochen.
Kochrezepte sind wie „imperative“ Programmierung: (von lat. imperare: anordnen, befehlen)

```
\\ Variablen
gramm mehl        = 300;
liter milch       = 0,6;
stueck eier       = 3;
prise salz        = 1; 
liter wasser      = 0,05;
essloeffel butter = 1;

\\ Methoden
void rühren();
void braten();

\\Hauptprogramm
pfannkuchen_machen {
    teig = mehl + milch + eier + salz;
    rühren(teig);
    teig = teig + wasser;
    rühren(teig);
    pfannkuchen = braten(reig);
}
```

### Aufbau eines Programms

Der Grundbaustein für ein Programm sind Anweisungen mit verschiedenen Untertypen:

1. Variablen deklarieren: Speicher für Daten reservieren
2. Variablen zuweisen: Werte oder Berechnungen im reservierten Speicher ablegen
3. Methodendeklarationen: eine bestimmte Sammlung von Anweisungen definieren, die unter einem Namen abgerufen werden kann, ggfs. mit Parametern
4. If-Anweisungen: Je nach Wert einer Bedingung, eine von mehreren Anweisungsblöcken ausführen
5. Schleifen: einen Anweisungsblock wiederholt ausführen

Aber nun erst einmal langsam, wir machen das Schritt für Schritt. 


* Ein Java-Programm ist in (Klassen), Methoden und Blöcke aufgeteilt, die ineinander verschachtelt sind.
* Blöcke werden durch die {}-Klammern geschachtelt.
* Der äußere Block umfasst die Klasse `Uebung`, der innere Block bildet den Methodenrumpf von `main` mit dem Aufruf der Methode `tueWas`.


```
public class Uebung{
    public static void main(String args[]){
        tueWas(0815);
    }
}
```

Genauer: 

* Hauptklasse oder Startklasse: Oberste Struktureinheit in Java
* Hauptmethode oder main-Methode genannt: Hier läuft das eigentliche Programm ab, ohne die main-Methode läuft das Programm nicht.
* Weitere Methoden: Es können für Teilberechnungen weitere Methoden definiert werden, die dann von der main-Methode aufgerufen werden. D.h. Methoden sind gespeicherte Anweisungen innerhalb eines Programms. Sie werden für einen bestimmten Zweck geschrieben und aufgerufen. Weiterhin kann man Methoden auch als Werkzeug betrachten. Man kann ein Werkzeug besitzen, aber es gar nicht einsetzen. 



### Übersetzen und Ausführen eines Programms

* Java-Programme können mit einem beliebigen Editor geschrieben werden. Die Dateiendung der Quell-Dateien lautet .java. Hier steht der Quellcode (engl. source)
* Der Java-Compiler `javac` übersetzt die Quelldatei in sogenannten Bytecode, dieser wird in der mit der Endung .class gespeichert.
* Die Java-Laufzeitumgebung (engl. Runtime Environment) `java` führt den Bytecode aus.
* Das Java-Programm von der Einführung gibt den Text „Hallo Welt“ am Bildschirm aus.

```java
class HalloWelt{
    public static void main(String args[]){
        System.out.println("Hallo Welt");
    }
}
```
@LIA.java(HalloWelt)

Das bedeutet

* Übersetzen: In Java wird Programmcode über einen Compiler in den Bytecode übersetzt (kompiliert). Dieser kann dann von einem Interpreter ausgeführt werden.

<p align="center">
<img src="programmausfuehren2.png" alt="ProgrammAusfuehren" width="60%">
</p>

* Eine Besonderheit von Java ist, dass ein Bytecode von verschiedenen Systemen verwendet werden kann: „Write once, run anywhere“

<p align="center">
<img src="bytecode2.png" alt="Bytecode" width="60%">
</p>

Wir wollen nun das Programm selbst schreiben. Hierzu benötigen Sie wie das Bild zeigt:

* Einen Java-Compiler
* Einen Java-Interpreter

Auf den Rechner in der Hochschule ist alles bereits installiert. Auf Ihrem eigenen Rechner können Sie auf die Schnelle einen externen Web-Editor nutzen, wie z.B. https://www.online-ide.com/online_java_editor, wenn Sie gleich los programmieren wollen. Im nächsten Kapitel erklären wir Ihnen zunächst wie man auf der Kommandozeile arbeitet und dann, wie Eclipse mit allem drum und dran installiert wird. 

---

**Aufgabe 1:** 

Führen Sie nun folgendes Quiz durch und testen Sie Ihr Wissen: 

**Frage 1**

Was macht der Compiler?

[(x)] Er erstellt .class-Dateien
[( )] Er verarbeitet .class-Dateien
[( )] Er führt das Programm aus

---

**Frage 2**

Was macht der Befehl `java`?

[( )] Er macht aus Qullcode Bytecode
[(x)] Er führt das Programm aus
[( )] Er verarbeitet .java-Dateien

---


###  Kommandozeile

**Arbeiten mit der Kommandozeile unter Windows:**

Zunächst machen wir ein paar Übungen auf der Kommandozeile:

- Öffnen der Kommandozeile

Um die Kommandozeile zu öffnen, drücken Sie `Windows + R` und geben Sie `cmd` in das Ausführen-Dialogfeld ein. Drücken Sie dann die Eingabetaste.

- Überprüfen des Benutzernamens

Um den Benutzernamen anzuzeigen, verwenden Sie den Befehl:

```
whoami
```

- Navigieren durch Verzeichnisse

Verwenden Sie `cd`, um zwischen Verzeichnissen zu wechseln. Beispiele:

```
cd            # Aktuelles Verzeichnis anzeigen
cd Desktop    # Zum Desktop wechseln
```

- Anzeigen des Verzeichnisinhalts

Verwenden Sie `dir`, um den Inhalt des aktuellen Verzeichnisses anzuzeigen:

```
dir
```

- Erstellen und Löschen von Ordnern

Verwenden Sie `mkdir` und `rmdir`, um Ordner zu erstellen und zu löschen:

```
mkdir practice    # Erstellt einen Ordner namens "practice"
rmdir Test        # Löscht den Ordner "Test"
```

- Anzeigen der Java-Version

Um die installierte Java-Version anzuzeigen, verwenden Sie:

```
java -version
```

- Überprüfen von Umgebungsvariablen

Um Umgebungsvariablen wie `JAVA_HOME` oder `PATH` zu überprüfen, verwenden Sie:

```
echo %JAVA_HOME%
echo %PATH%
```

- Beenden der Eingabeaufforderung

Um die Eingabeaufforderung zu schließen, geben Sie einfach ein:

```
exit
```

**Kommandozeile und Java-Code**

Um einen Java-Code im Texteditor zu erstellen und dann auf der Kommandozeile zu kompilieren und auszuführen, können Sie die folgenden Schritte befolgen:

1. **Öffnen Sie Ihren Texteditor:** Verwenden Sie ein beliebiges Textbearbeitungsprogramm wie Notepad, Editor, TextPad, UltraEdit, Kate, gedit, Emacs, vi oder ein anderes, das "plain text" (unformatierten Text) speichern kann.

2. **Schreiben Sie Ihren Java-Code:** Erstellen Sie eine neue Datei und geben Sie Ihren Java-Code ein. Zum Beispiel:

```java
public class HalloWelt {
    public static void main(String[] args) {
        System.out.println("Hallo Welt!");
    }
}
```

3. **Speichern Sie die Datei:** Speichern Sie die Datei mit der Erweiterung ".java". Zum Beispiel: "HalloWelt.java". Wichtig: Die Datei muss so heißen, wie Ihre Klasse heißt. In diesem Fall: HalloWelt

4. **Öffnen Sie die Eingabeaufforderung oder das Terminal:** Navigieren Sie zu dem Verzeichnis, in dem sich Ihre Java-Datei befindet.

5. **Kompilieren Sie den Java-Code:** Verwenden Sie den Befehl `javac`, um den Java-Code zu kompilieren. Wenn Sie möchten, können Sie die kompilierten Dateien in einem separaten Ordner speichern. Beispiel:

```bash
javac HalloWelt.java
```

oder

```
javac -d . HalloWelt.java
```

Der `-d`-Schalter gibt an, in welchem Verzeichnis die kompilierten `.class`-Dateien gespeichert werden sollen. Hier wird der Punkt verwendet, um die Dateien im aktuellen Verzeichnis zu speichern.

6. **Führen Sie das Programm aus:** Verwenden Sie den Befehl `java`, um das Programm auszuführen. Verwenden Sie den Klassennamen ohne die Erweiterung ".class". Beispiel:

```
java HalloWelt
```

7. **Überprüfen Sie die Ausgabe:** Das Programm sollte ausgeführt werden und die Ausgabe auf der Konsole anzeigen. In diesem Fall würde es "Hallo Welt!" ausgeben.

Durch das Befolgen dieser Schritte können Sie einen Java-Code im Texteditor erstellen, kompilieren und ausführen, ohne eine integrierte Entwicklungsumgebung (IDE) zu verwenden. Dies ist auf Dauer aber sehr mühsam, wie Sie vielleicht an diesem kleinen Beispiel schon bemerkt haben. 

### Installation von Eclipse

Wir werden im 1. Semester mit der IDE (dies ist die Abkürzung für integrierte Entwicklungsumgebung von engl. integrated development environment) arbeiten. Eine IDE macht Ihne das Leben sehr viel leichter. Sie sollten, wenn möglich, Eclipse auch auf Ihrem privaten Rechner installieren, um auch zu Hause üben zu können. 

Führen Sie also diese Schritte auf Ihrem Laptop oder Rechner zu Hause durch, so dass Sie für das Semester ausgerüstet sind. Auf den Rechnern der Hochschule ist alles bereits installiert. 

1. Öffnen Sie Ihren Webbrowser und besuchen Sie die offizielle Eclipse-Website unter https://www.eclipse.org/downloads/.

2. Herunterladen des Installationsprogramms („Download x86_64“)
![](installation_1.JPG) <br>

3. Bestätigung des Downloads vom ausgewählten Server
![](installation_2.JPG)

4. Wechsel in den „Downloads“-Ordner und Start des heruntergeladenen Programms
`eclipse-inst-jre-win64.exe`

5. Auswahl des Eintrags `Eclipse IDE for Java Developers`

<p align="center">
<img src="installation_3.JPG" alt="Auswahl Eintrag" width="60%">
</p>



6. Bestätigen der Standardeinträge für die JVM und den Installationsordner
<p align="center">
<img src="installation_4.JPG" alt="Bestätigung Installationsordner" width="60%">
</p>

7. Auswahl/Anlegen des Eclipse Workspace und "Launch"
<p align="center">
<img src="installation_5.JPG" alt="Auswahl des Eclipse Workspace" width="60%">
</p>


**Führung durch Eclipse:**

Absolvieren Sie dann die Anleitung zum Erstellen eine Hello World-Projekts:

<p align="center">
<img src="installation_5b.JPG" alt="Hello World" width="75%">
</p>

**Start des ersten Projekts:**
Ein Eclipse-Projekt starten Sie unter:
<p align="center">
<img src="installation_5d.JPG" alt="Java Projekt starten" width="75%">
</p>


Oder, wenn Sie den Start-Bildschirm nicht sehen, klicken Sie links oben auf File -> New -> Java Project -> Project name eingeben
<p align="center">
<img src="installation_6a.JPG" alt="Java Projekt starten" width="50%">
</p>


Geben Sie oben einen Projektnamen ein und deslektieren Sie das Häckchen der module-info.java!
Danach klicken Sie auf `Finish`.
<p align="center">
<img src="installation_6b.JPG" alt="Projektname" width="60%">
</p>

Wir arbeiten zunächst ohne Module und auch ohne Packages. 

Um nun eine Klasse zu erstellen, rechtsklicken Sie auf das Projekt `ErstesProjekt`, wählen Sie `New`, dann `Class`.
<p align="center">
<img src="installation_8b.JPG" alt="Klasse anlegen" width="60%">
</p>

 Geben Sie einen Namen für die Klasse ein, wählen Sie aus, dass die Main-  und klicken Sie auf `Finish`.
<p align="center">
<img src="installation_9b.JPG" alt="Klassenname" width="60%">
</p>


Erstellen Sie nun Ihr gewünschtes Programm. Zum Ausführen des Programms dann einfach den grünen `Run As` Button drücken:
![](installation_10.jpg)

### Übungen

**Aufgabe 1:** 
Recherchieren Sie ein Pfannkuchenrezept und versuchen Sie die einzelnen Schritte nachzuvollziehen. Natürlich dürfen Sie dieses Rezept auch nachkochen. Was sind die Variablen und Methoden in dem Rezept?

**Aufgabe 2:** 
Erstellen Sie mit Hilfe eines einfachen Texteditors ein Programm `HalloStudent.java`, welches Ihren Namen auf Konsole ausgibt. 

* Übersetzen Sie das Programm mit `javac HalloStudent.java`
* Führen Sie es mit `java HalloStudent` aus
* Suchen Sie den erzeugten Binärcode

**Aufgabe 3:** 
Programmieren mit Eclipse: Machen Sie Aufgabe 2 mit Eclipse.

Wenn Sie ein kleines Programm auf der Kommandozeile ausführen können, dieses auch in der IDE läuft und Sie dazu verstanden haben, welche Schritte im Hintergrund ausgeführt wurden, dann sind Sie bereit für das nächste Kapitel. 



## Variablen und Datentypen 

Schauen Sie sich folgendes Beispiel an und überlegen Sie sich für jede Zeile, was das Programm tun könnte und welche Ausgabe der Code Ihrer Meinung nach erzeugt.

```java
class Variablen {
    public static void main(String[] args) {

        byte b = 1;
        System.out.println(b);

        short s = 250;
        System.out.println(s);

        int i = 5;
        System.out.println(i);

        long l = 105464560L;
        System.out.println(l);

        float f = 1.5f;
        System.out.println(f);

        double d = 1.8;
        System.out.println(d);

        char c = 'a';
        System.out.println(c);

        char c2 = 65;
        System.out.println(c2);

        boolean bl = true;
        System.out.println(bl);
    }
}
```
@LIA.java(Variablen)


* Führen Sie nun den Code aus und überprüfen Sie Ihre Vermutung. 

* Ändern Sie den Code ab und probieren Sie aus, ob das Programm noch läuft und was die Ausgabe ist. 

Achtung: Wenn Sie eine rote Ausgabe erhalten, haben Sie einen fehlerhaften Code erzeugt. Können Sie den Code wieder berichtigen?

* Gehen Sie nun auf die nächste Seite und arbeiten Sie die Erklärungen durch.


### Variablen deklarieren
Der Speicher im Computer besteht nur aus einer langen Folge von 0en und 1en. Jeweils 8 werden zu einem Byte zusammengefasst. Die Bytes werden durchnummeriert (beginnend bei 0). Die Nummer eines Bytes ist dessen Adresse.

Variablen geben einer bestimmten Speicherstelle einen Namen und einen Typen:

* Einfacher zu merken als eine Speicheradresse
* Kann gleich bleiben, auch wenn sich die Speicheradresse ändert
* Der Typ kann bestimmte Arten von Programmfehlern verhindern und bestimmt wie viele Bytes die Variable umfasst

Eine Variable ist also eine Art Gefäß im Speicher. Werte können überprüft, verändert und vor allem gespeichert werden.
Variablen haben einen bestimmten TYP, eine ADRESSE im Speicher, einem NAMEN und natürlich einem WERT. Java ist eine statisch typisierte Programmiersprache. Das bedeutet, dass jede Variable einen festen Typ hat, der bereits zur Übersetzungszeit bekannt ist (hierzu später mehr).

Wie funktioniert nun die Deklaration von Variablen in Java:

```
int schuhgroesse;  // Das hier ist übrigens ein Kommentar
char buchstabe1, buchstabe2, buchstabe3; // Hiervon braucht man oft mehrere
double temperatur; // Kommazahl
boolean sonnigerTag; // wahr/falsch, ja/nein -> boolean
```

In Java können wir Variablen direkt bei der Deklaration mit einem Wert initialisieren, hier *Literals* also Konstanten im Programmtext:

```
int schuhgroesse = 42;
double temperatur = 20.2; // Ohne Einheit - müssen wir uns separat merken
double wunschEinkommen = 50_000; // Euro? Brutto/Netto? Im Jahr oder Monat?
boolean sonnigerTag = true;
```

Allgemein also: 

```
Datentyp Variablenname = Wert;
```
In einem kleinen Programm könnte das so aussehen: 

```java
class Schuhgroesse {
    public static void main(String[] args) {
        int schuhgroesse = 42;
        System.out.println("Meine Schuhgröße ist: " + schuhgroesse);
   }
}
```
@LIA.java(Schuhgroesse)

Hinweis: Man muss einer Variable nicht sofot einen Wert geben. Dies kann auch später geschehen. Die Variable erhält dann zunächst einen Standardwert - je nach Datentyp. 


Hier finden Sie eine Übersicht über verschiedene primitive Datentypen, das sind die elementaren Datentypen. 

<!-- data-type="None" -->
| Datentyp   | Bit   | Minimum   | Maximum   |
| :--------- | :--------- | :--------- | :--------- |
| byte    | 8-Bit     | -128    | 127    |
| short    | 16-Bit     | -32768    | 32767    |
| int    | 32-Bit     | -2147483648    | 2147483647   |
| long    | 64-Bit     | -9223372036854775808    | 9223372036854775807    |
| float    | 32-Bit     | -3.4 * (10<sup>38</sup>)    | 3.4 * (10<sup>38</sup>)      |
| double    | 64-Bit     | -1.7 * (10<sup>308</sup>)    | 1.7 * (10<sup>308</sup>)    |

Weiterhin gibt es noch die beiden Datentypen `boolean` und `char`: 

<!-- data-type="None" -->
| Datentyp   | Bit   |Werte   |
| :--------- | :--------- | :--------- | 
| boolean    | 1 Byte     | true / false   | 
| char    | 2 Byte     | Ein Unicode-Zeichen  | 

Primitive Typen werden immer klein geschrieben. 

Hinweis: Ein char ist intern als Zahlen codiert (z.B. A → 65) – deshalb kann mit char gerechnet werden.

Weiterhin gibt es Referenztypen, welche auf Klassen basieren (z.B. String). Diese werden groß geschrieben. 

Java ist eine streng typisierte Sprache, d.h. Java erlaubt es nicht, Variablen die für einen Typ deklariert sind mit Werten aus einem anderen Typ zu belegen. Beim Übersetzen des Quellcodes wird geprüft, ob alle Werte zu den geforderten Typen passen – also auch Variablenwerte und Variablentypen.
Eclipse prüft dies bereits beim Schreiben und meldet ggf. einen Fehler


Bei der Benennung von Variablen ist es wichtig, einige Regeln zu beachten:

* Am Anfang muss ein Buchstabe (oder `_`) stehen.
* Danach können Buchstaben oder Ziffern folgen.
* Erlaubt (aber nicht empfohlen) sind: `$, _, ä, ö, ü, ß, €, …` (wobei `$` oft für generierte Namen verwendet wird.)
* Nicht erlaubt sind Sonderzeichen wie `!, ?, *, /, … `
* Groß- und Kleinschreibung ist relevant. Das bedeutet, dass Variablennamen wie `glueckszahl` und `gluecksZahl` unterschiedlich sind.
* Variablennamen sollten zusammengeschrieben werden, also ohne Leerzeichen.
* Schlüsselwörrter dürfen nicht als Variablennamen verwendet werden, da sie zum Sprachumfang von Java gehören

* Eine häufige Konvention ist die Verwendung von „CamelCase“:

  * Variablen, Methoden und Pakete beginnen klein und jedes neue Wort beginnt groß, z.B. kleinAnfangenUndJedesWortGrossBeginnen.
  * Klassennamen beginnen groß und jedes neue Wort beginnt groß, z.B. GrossAnfangenUndJedesWortGrossBeginnen.

**Merke:**
Gute Variablennamen sind nicht zu kurz und nicht zu lang. Sie sind immer aussagekräftig (z.B. int alterInTagen), nur temporäre Variablen dürfen auch mal kürzer sein (z.B. in Schleifen, vgl. folgendes Kapitel). Der Typ der Variable sollte nicht im Namen aufgeführt werden. Der Compiler meldet zurück, ob der Name gültig ist, nicht ob dieser sinnvoll gewählt ist.

### Variablen zuweisen
Die Initialisierung hat den Variablen direkt bei der Speicherreservierung einen Wert zugewiesen. Nachdem eine Variable angelegt wurde können wir ihr einen (neuen) Wert zuweisen:

```java
class Temperatur {
    public static void main(String[] args) {
        double temperatur = 18.1;
        System.out.println("Die Temperatur ist: " + temperatur + " Grad.");
        System.out.println("Die Sonne scheint...");
        temperatur = 24.5;
        System.out.println("Nun ist die Temperatur: " + temperatur + " Grad.");
   }
}
```
@LIA.java(Temperatur)

Sie sehen im Programmcode die Zuweisungen. Links vom Gleichheitszeichen steht der Name einer bereits deklarierten Variable. Rechts vom Gleichheitszeichen steht ein Ausdruck.

Für Ausdrücke gibt es verschiedene Aufbauten:

* Literale - das sind konstante Werte, die direkt im Programmtext geschrieben werden, z.B. `8`, `17.4`, `'a'`, `"Hallo Welt"`
* Variablen - der Name einer bestehenden Variable, dieser wird bei der Auswertung des Ausdrucks mit dem aktuellen Wert der Variable ersetzt, z.B. `schuhgroesse`
* Methodenaufrufe - es wird Code, der unter dem Methodennamen abgespeichert ist, ausgeführt und das Ergebnis zurück geliefert, z.B. `readInt()`, manche Methoden nehmen Parameter (wiederum Ausdrücke), z.B. `System.out.println("Hallo Welt")`
* Operationen: hier werden eine oder mehrere (meistens zwei) Ausdrücke mit einem Operator verknüpft, z.B. `schuhgroesse + wunschEinkommen`

In Java müssen wir den Wert eines Ausdrucks einer Variable zuweisen:

```
double komischeZahl = schuhgroesse + wunschEinkommen;
```

oder uns per Methodenaufruf ausgeben:

```
System.out.println("Hallo " + "Programmieren " + 1)
```
Mit Operationen und Methodenaufrufen können komplexe Ausdrücke geschafften werden, z.B.:

```
System.out.println("In Fahrenheit: " + ((readDouble() * 9.0/5.0) + 32))
```
Auch dazu später mehr.

Ausdrücke werden von innen nach außen ausgewertet, d.h. bei verschachtelten Ausdrücken erst die Sachen in Klammern, bzw. nach Prioritäten ("Punkt vor Strich).

Bei Zuweisungen wird erst die rechte Seite berechnet und dann erst die links genannte Variable aktualisiert. Überlegen Sie, was folgender Programmcode somit ausgibt. Probieren Sie dies dann aus.

```java
class Wert {
    public static void main(String[] args) {
       int wert = 10;
       System.out.println("Der Wert ist: " + wert);
       wert = wert + 1;
       System.out.println("Der Wert ist nun: " + wert);
   }
}
```
@LIA.java(Wert)


### Operatoren
Übersicht über wichtige Java-Operatoren:

| Operator | Beschreibung                                    |
|----------|-------------------------------------------------|
| +        | Addition von Zahlen oder Verkettung von Strings |
| -        | Subtraktion von Zahlen                          |
| *        | Multiplikation von Zahlen                       |
| /        | Division von Zahlen                             |
| %        | Modulo (Rest bei der Division)                  |
| +=       | Addition und Zuweisung                          |
| -=       | Subtraktion und Zuweisung                       |
| ++       | Inkrement (Erhöhung um eins)                    |
| --       | Dekrement (Verminderung um eins)                |


Von den Standardoperatoren `+`, `-`, `*` (Mal), `/` (geteilt durch) für Zahlen gibt es auch jeweils eine Version, die gleich die Zuweisung integriert. 

Überlegen Sie, welchen Wert `x` im folgenden Programm hat. Fügen Sie eine Zeile im Programmcode für die Ausgabe hinzu und überprüfen Sie Ihre Überlegung.


```java
class Operatoren1 {
    public static void main(String[] args) {
        int x = 5;
        x += 5; // Gleichbedeutend mit x = x + 5
   }
}
```
@LIA.java(Operatoren1)


Was ist `y` am Ende des folgenden Programmcodes? Fügen Sie auch hier eine Zeile für die Ausgabe hinzu, um Ihre Überlegung zu überprüfen.

```java
class Operatoren2 {
    public static void main(String[] args) {
        int y = 2;
        y *= y; // Gleichbedeutend mit y = y * y;
   }
}
```
@LIA.java(Operatoren2)


Häufig zählen wir Variablen um eins nach oben oder eins nach unten, hier gibt die Kurzformen `i++` und `i--`. Sie liefern den Wert von `i` zurück und danach wird `i` inkrementiert bzw. dekrementiert. Versuchen Sie folgenden Code nachzuvollziehen:


```java
class Operatoren3 {
    public static void main(String[] args) {
        int i = 0;
        System.out.println(i++); // Gibt 0 aus und erhöht dann i auf 1
        System.out.println(i); // Gibt den neuen Wert von i (1) aus
        System.out.println(i--); // Gibt 1 aus und verringert dann i auf 0
        System.out.println(i); // Gibt den neuen Wert von i (0) aus
   }
}
```
@LIA.java(Operatoren3)


Weniger verbreitet sind die Formen `++i` und `--i`, die zuerst `i` inkrementieren bzw. dekrementieren und dann den Wert zurückliefern. Dies liefert folgendes, doch etwas überraschende Eregebnis:

```java
class Operatoren4 {
    public static void main(String[] args) {
        int i = 0;
        System.out.println(++i); // Erhöht i zuerst auf 1 und gibt dann 1 aus
        System.out.println(i); // Gibt den aktuellen Wert von i (1) aus
        System.out.println(--i); // Verringert i zuerst auf 0 und gibt dann 0 aus
        System.out.println(i); // Gibt den aktuellen Wert von i (0) aus
   }
}
```
@LIA.java(Operatoren4)

Nützlich ist der Modulo-Operator `%` - er liefert den Rest bei einer Ganzzahlendivision, z.B.:

```java
class Operatoren5 {
    public static void main(String[] args) {
        int zahl = 22;
        int divisor = 4;
        int rest = zahl % divisor;
        System.out.println(rest); // Der Wert ist 2, da 22/4 = 5 Rest 2 ist
   }
}
```
@LIA.java(Operatoren5)

Weitere Operatoren sind Vergleichsoperatoren (`==`, `!=`, `<=`, `>=`, `<`, `>`), Bit-Operatoren (`&`, `|`, `<<`, `>>`) und logische Operatoren (`&&`, `||`)


### Sichtbarkeit von Variablen
„Sichtbar“ bedeutet: Die Variable kann vom folgendem Code verwendet werden. Variablen sind erst sichtbar, nachdem sie deklariert wurden.

Neben den Variablen, die wir innerhalb einer Methode deklarieren (bisher in der main-Methode), gibt es auch noch statische Klassenvariablen. Diese sind in der gesamten Klasse sichtbar und das Programm kann hierauf zugreifen, sobald es gestartet wurde. Eine statische Klassenvariable kann von mehreren Methoden einer Klasse verwendet werden. Sie wird im Rumpf einer Klassendeklaration geschrieben (nicht im Rumpf einer Methodendeklaration). 

Hier ein Beispiel:

```java
class Klassenvariable {
    public static int zahl = 10; //statische Klassenvariable

    public static void main(String[] args) {
        int neueZahl = zahl + 10; //lokale Variable, nur innerhalb der Methode sichtbar
        System.out.println(neueZahl);
   }
}
```
@LIA.java(Klassenvariable)

* `static` bedeutet für uns zunächst etwa "von Anfang an vorhanden", "der Klasse zugeordnet"
* Variablen ohne den Modifier `static` sind den Objekten zugeordnet (ab Kapitel Klassen und Objekte)
* Lokale Variablen sind nur innerhalb des Blocks sichtbar

Weiterhin gibt es noch statische Klassenkonstanten. Diese werden mit dem Schlüsselwort `final` deklariert. Hier sind Änderungen nur an einer Stelle möglich. Dies erleichter die Lesbarkeit. 

```
\\ statt den Wert als Literal fest im Code anzugeben
double umfang = 2.0 * radius * 3.14159;
double flaeche = radius * radius* 3.14159;

\\ wird der Wert als Klassenkonstante deklariert
public static final double PI = 3.14159;
double umfang = 2.0 * radius * PI;
double flaeche = radius * radius * PI;

```
Konstanten werden groß geschrieben. 

**Lebensdauer von Variablen**

Klassenvariable: beginnt mit dem Laden der Klasse und endet mit dem Ende des Programms
Lokale Variable: beginnt mit der Deklaration im Block und endet mit dem Blockende (schließende })


### Konvertierung
In Java können verschiedene primitive Datentypen durch Umwandlung konvertiert werden. Dabei unterscheidet man zwei Fälle: 

* Widening = Erweitern: eine Variable von einem Typ mit einem kleinen Wertebereich wird in eine Variable von einem Typ mit einem größeren Wertebereich umgewandelt. Dies stellt in der Regel kein Problem dar.


```java
class Widening {
    public static void main(String[] args) {
		byte kleinsterTyp = 5;
		short kleinerTyp = kleinsterTyp;
		int grosserTyp = kleinerTyp;
		
		System.out.println(grosserTyp);
   }
}
```
@LIA.java(Widening)

* Narrowing = Eingrenzen: Gegenteil zu Widening -> hier ist Casting erforderlich

```java
class Narrowing {
    public static void main(String[] args) {
		byte kleinsterTyp = 5;
		short kleinerTyp = kleinsterTyp;
		int grosserTyp = kleinerTyp;
		
		// Type Mismatch
		// kleinerTyp = grosserTyp;
		
		// so geht's mit Narrowing
		kleinerTyp = (short) grosserTyp;
   }
}
```
@LIA.java(Narrowing)

Was ergibt dann folgendes Beispiel?

```java
class Konvertierung {
    public static void main(String[] args) {
		short zahl = 128;
		byte kleinesByte = (byte) zahl;
		// Was kommt hier heraus?
		System.out.println(kleinesByte);
   }
}
```
@LIA.java(Konvertierung)


### Übungen

**Aufgabe 1:** 

Führen Sie folgendes Quiz durch und testen Sie Ihr Wissen: 


**Frage 1**

Welcher Variablentyp würde am besten verwendet werden, um die Temperatur `42,2` Grad zu speichern?

[( )] Integer
[(x)] Float
[( )] String
[( )] Boolean

---

**Frage 2**

Welcher Variablentyp wird verwendet, um einzelne Buchstaben zu speichern?

[(x)] Char
[( )] Integer
[( )] Float
[( )] String

---

**Frage 3**

Welcher Variablentyp könnte verwendet werden, um alle Menschen auf der Welt zu nummerieren?

[( )] Char
[( )] Float
[(x)] Long
[( )] Integer

---

**Frage 4**

Welcher Variablentyp wird verwendet, um einen Satz zu speichern?

[( )] Char
[( )] Integer
[( )] Float
[(x)] String

**Weitere Aufgaben:**   

Machen Sie die Aufgaben aus der [Aufgaben-Datenbank](https://speiser.hft-pages.io/programmieraufgaben/2024-ss-pro-1/) aus Kapitel 01.

### Ablage 

* Variablen: Werden in Lower Camel Case benannt, wie z.B. alterInTagen
* Klassen: Werden in Upper Camel­Case benannt, wie z.B. TageDesJahres
* Konstanten (ändern sich nicht): komplett in Großbuchstaben (als Trennzeichen typischerweise Unterstrich), wie z.B. ANZAHL_JAHRESZEITEN

Und noch ein paar Tipps für die Arbeit in Eclipse:

* Vervollständigung: Strg + Leertaste
* Formatieren: Source -> Format oder Strg+Shift+F
* Umbenennen: rechte Maustaste -> Refactor -> Rename


## Kontrollflusss

Der Kontrollfluss in Java ermöglicht es uns, den Ablauf unseres Codes zu steuern, indem wir Entscheidungen treffen und Schleifen verwenden. Kontrollflussstrukturen wie bedingte Anweisungen und Schleifen ermöglichen es uns, unseren Code dynamisch zu gestalten und verschiedene Pfade je nach Bedingungen oder Anforderungen auszuführen.

Schauen Sie sich folgendes Beispiel an und überlegen Sie sich für jede Zeile, was das Programm tun könnte und welche Ausgabe der Code Ihrer Meinung nach erzeugt.

```java
class DemoKontrollfluss{
    public static void main(String args[]){
        int zahl = 10;

        if (zahl % 2 == 0) {
            System.out.println(zahl + " ist eine gerade Zahl.");
        } else {
            System.out.println(zahl + " ist eine ungerade Zahl.");
        }
        
        System.out.println("Zahlen von 1 bis 5:");
        for (int i = 1; i <= 5; i++) {
            System.out.println(i);
        }
    }
}
```
@LIA.java(DemoKontrollfluss)

Führen Sie nun den Code aus und überprüfen Sie Ihre Vermutung.



### If-Verzweigung
Die if-Anweisung ist die einfachste Kontrollstruktur. Man kann sich diese wie folgt vorstellen:

<p align="center">
<img src="if.png" alt="if-Anweisung" width="25%">
</p>

Sie wird wie folgt dargestellt:

```
if (Bedingung) {
    //Wenn die Bedingung `true` ist
    Anweisung;
}
```

Ist die Bedingung wahr, werden die Anweisungen der nächsten Zeile, bzw. des Blockes ausgeführt, ansonsten passiert nichts! Beim Auswerten der Bedingung muss immer ein Boolescher Wert entstehen.



**Wie können diese Bedingungen aussehen?**

In Programmiersprachen werden häufig Vergleiche zwischen Werten mittels Operatoren durchgeführt, um Bedingungen zu überprüfen. Hier sind einige gängige Vergleiche:

- `a > 0`: Überprüft, ob der Wert von "a" größer als 0 ist.
  
- `c == d`: Überprüft, ob der Wert von "c" gleich dem Wert von "d" ist, zum Beispiel, ob zwei Ganzzahlen gleich sind.
  
- `e != 1`: Überprüft, ob der Wert von "e" ungleich 1 ist.
  
- `"Müller".equals("Meier")`: Überprüft die Gleichheit von zwei Strings, in diesem Fall, ob der String "Müller" gleich dem String "Meier" ist.

Diese Bedingungen können in `if`-Schleifen verwendet werden, um Entscheidungen im Code zu treffen. Ändern und ergänzen Sie folgendes Programm so, dass in der if-Verzweigung `"Der if-Block wurde ausgeführt"` ausgegeben wird. 


```java
class IfAnweisung{
    public static void main(String args[]){
    int f = 3;
    if (f > 5) {
        // Führe diesen Codeblock aus, wenn "f" größer als 5 ist
        }
    }
}
```
@LIA.java(IfAnweisung)



**Logische Operatoren können wie folgt aussehen:**

| Operator | Beschreibung                                                                                        |
|----------|-----------------------------------------------------------------------------------------------------|
| !        | Negation: Dreht den Wahrheitswert um (aus `true` wird `false` und aus `false` wird `true`)      |
| &        | Und mit vollständiger Auswertung: Liefert `true`, wenn beide Ausdrücke `true` sind               |
| \|       | Oder mit vollständiger Auswertung: Liefert `true`, wenn einer oder beide Ausdrücke `true` sind   |
| &&       | Und mit verkürzter Auswertung: Wie &, jedoch wird sofort `false` zurückgegeben, wenn der erste Ausdruck `false` ist |
| \|\|     | Oder mit verkürzter Auswertung: Wie \|, jedoch wird sofort `true` zurückgegeben, wenn der erste Ausdruck `true` ist  |
| \^       | Exklusives Oder: Liefert nur `true`, wenn genau einer der beiden Ausdrücke `true` ist             |



Welche Anweisungen eignen sich für Bedingungen?

1. 4<10
[(x)] wahr
[( )] falsch

2. int a = 0;
[( )] wahr
[(x)] falsch

3. String name = "Schulze"; name.equals("Meier") 
[(x)] wahr
[( )] falsch

4. 4 == 4 && 5 == 5 
[(x)] wahr
[( )] falsch

5. 4 == 4 && 5 == 5 
[(x)] wahr
[( )] falsch


Ändern und ergänzen Sie folgendes Programm nun so, dass der if-Block dann ausgeführt wird, wenn f < 5 und gleichzeitig t = 7 ist. 

```java
class If{
    public static void main(String args[]){
    int f = 3;
    if (f > 5) {
        System.out.println("Der if-Block wird gerade ausgeführt.");
        }
    }
}
```
@LIA.java(If)



**if/else Anweisungen**

Die `else`-Anweisung erweitert die Kontrollstruktur von `if`, um einen Zweig hinzuzufügen, der ausgeführt wird, wenn die Bedingung der `if`-Anweisung nicht erfüllt ist. 

<p align="center">
<img src="ifelse.png" alt="if/else-Anweisung" width="35%">
</p>


Die `if/else`-Anweisung hat die folgende Syntax:

```java
if (Bedingung) {
    // Wenn die Bedingung `true` ist
    Anweisung;
} else {
    // Wenn die Bedingung `false` ist
    Alternative_Anweisung;
}
```

Wenn die Bedingung der `if`-Anweisung wahr ist, werden die Anweisungen innerhalb des `if`-Blocks ausgeführt. Andernfalls werden die Anweisungen innerhalb des `else`-Blocks ausgeführt.

Die `else`-Anweisung ist optional und kann allein oder in Kombination mit einer `if`-Anweisung verwendet werden, um alternative Aktionen basierend auf Bedingungen auszuführen.

Beispiel:

```java
class Semester{
    public static void main(String args[]){
        int semester = 2;
        if ( semester == 1 ) {
        System.out.println("Ihr Fach ist PRO1");
        } else {
        System.out.println("Ihr Fach ist PRO2");
        }       
    }
}
```
@LIA.java(Semester)

Was müssen Sie abändern, wenn Ihr Fach dieses Semester PRO1 ist?

Die `else`-Anweisung kann auch mit verschachtelten `if`-Anweisungen verwendet werden, um komplexere Entscheidungsstrukturen zu erstellen.

```
if ( Bedingung 1 ){   
    Anweisung1;
} else {    
    if ( Bedingung 2 ){        
        Anweisung2;    
    } else {        
        Anweisung3;    
    }
}      
```

Enthält der `else`-Zweig lediglich ein weiteres if (ggf. mit else), können die Anweisungen auch fortgesetzt werden:

```
if ( Bedingung 1 ) {
        Anweisung1;
    } else if ( Bedingung 2 ){ 
        Anweisung2;
    } else if ( Bedingung 3 ){   		
        Anweisung3;
    } else {    
        Anweisung4;
    }   
```


Schreiben Sie eine if/else-Verzweigung für den folgenden Fall:

* Wenn die Temperatur unter 20°C liegt, geben Sie „Jacke!“ aus, 
* Wenn sie zwischen 20°C und 28°C liegt, geben Sie „T-Shirt!“ aus, 
* wenn sie über 28°C liegt, „Badeanzug!“


```java
class Temperatur2{
    public static void main(String args[]){
      
    }
}
```
@LIA.java(Temperatur2)


**Der bedingte Ausdruck**

- Der bedingte Ausdruck ist keine Anweisung sondern ein Operatorausdruck, also etwas, das in einem Ausdruck (z.B. einer Formel) eingesetzt werden kann. Vergleichbar mit der WENN( ; ; ) Formel in Excel: (Bedingung) ? Ausdruck1 : Ausdruck2
 
- Wenn die Bedingung wahr ist, so ist der Wert des Ausdrucks identisch mit Ausdruck1, sonst mit Ausdruck2
Beide Ausdrücke müssen vom selben Werttyp (int, char, String, etc.) sein

```
int urlaubstage = (alter > 28 ? 30 : 25);
```

Erstellen Sie ein Programm, dass Ihnen Ihre an Urlaubstage ausgibt. Wenn Sie älter als 30 Jahre sind, haben Sie 32 Urlaubstage, wenn Sie jünger sind, nur 28 Tage. 


```java
class Urlaubstage{
    public static void main(String args[]){
      
    }
}
```
@LIA.java(Urlaubstage)



**switch/case**

Die switch-Anweisung bietet eine alternative Methode zur Kontrollstruktur if, insbesondere wenn eine Variable auf verschiedene Werte geprüft werden soll und abhängig vom Wert unterschiedliche Aktionen ausgeführt werden sollen.

Die Syntax einer `switch`-Anweisung sieht folgendermaßen aus:
![](switchcase.JPG)

- Der switch-Ausdruck muss Ergebnisse vom Typ byte, short, int, char, String oder Enumeration zurückliefern
- Im case-Teil müssen Konstanten stehen (keine Variablen, Funktionsaufrufe o.ä.)
- Die Konstanten im case-Teil müssen vom gleichen Typ wie der switch-Ausdruck sein (also auch byte, short, int, char oder String)
- Kein Wert der Konstanten dieser case-Zweige darf doppelt auftreten. Die Reihenfolge ist egal.
- Nach dem case kommt eine Folge von Anweisungen; üblicherweise abgeschlossen durch ein return oder break
- break ist optional – wenn es fehlt, wird die Bearbeitung mit dem nächsten case (ohne Prüfung!) fortgesetzt – aber Vorsicht: Fehler durch vergessene break sind schwierig zu finden.
- der default-Zweig ist optional; es ist höchstens einer zulässig

Testen Sie Ihr Wissen nun, indem Sie ein Programm schreiben das den heutigen Wochentag als Variable initalisiert und dann Ihre Vorlesungen für den jeweiligen Wochentag auf der Konsole ausgibt. Nutzen Sie hierfür am Besten Eclipse. Wenn Sie wollen, können Sie es aber auch direkt im Workbook erstellen.

```java
class Stundenplan{
    public static void main(String args[]){
      
    }
}
```
@LIA.java(Stundenplan)


### Zählschleife ("normale for-Schleife")
Die Schleife wird von einer Anfangszahl bis zu einer Endzahl mit einer vorgegebenen Schrittweite wiederholt.

<p align="center">
<img src="forSchleife.png" alt="For-Schleife" width="70%">
</p>


Im Code sieht dies dann so aus:

```java
class Zaehlschleife{
    public static void main(String args[]){
        for (int i = 0; i < 10; i++){
          System.out.println(i);
        }
    }
}
```
@LIA.java(Zaehlschleife)

Wie müssen Sie das Programm abändern, um die ungeraden Zahlen von 1 bis 20 aufzusummieren?


**Anmerkungen**

- Eine im Schleifenkopf deklarierte Variable ist nur innerhalb der Schleife sichtbar.
- `break` verlässt die Schleife
- `continue` springt zum Ende der Schleife
- Teile des Kopfes können leer bleiben (z.B. stellt for(;;) eine Endlosschleife dar).

**Weiteres Beispiel**

Was wird im folgenden Programm berechnet?

```java
class Zaehlschleife2{
    public static void main(String args[]){
        int n = 4;
        int fakultaet = 1;
        for(int i = 1; i<=n; i++) {
            fakultaet *= i;
        }
        System.out.println(n + "! ? " + fakultaet);
    }
}
```
@LIA.java(Zaehlschleife2)


### For-Each-Schleife (Mengenschleife)

Die Schleife führt den Rumpf für jedes Element der Menge aus. 

```java
class ForEach{
    public static void main(String args[]){
        String[] f = {"eins", "zwei", "drei"}; //Dies ist ein Array und wird im nächsten Kapitel erklärt
        for(String s : f) {
            System.out.println(s);
        }
    }
}
```
@LIA.java(ForEach)

Dies schauen wir uns später noch genauer an, wenn wir verschiedene Mengen betrachten, z.B. im Zusammenhang mit Collections.


### While-Schleife
Die while-Schleife wird verwendet, um einen Codeblock wiederholt auszuführen, solange eine bestimmte Bedingung erfüllt ist. Die Bedingung wird vor jeder Ausführung des Codeblocks überprüft und muss ein boolescher Ausdruck sein.

<p align="center">
<img src="while.png" alt="While-Schleife" width="25%">
</p>


Schauen Sie sich folgendes Programm an. Was passiert hier?

```java
class While{
    public static void main(String args[]){
        int zaehler = 15;
        while (zaehler < 20) {
            System.out.println(zaehler);
            zaehler++;
        }
    }
}
```
@LIA.java(While)

Können Sie es so modifizieren, dass alle geraden Zahlen ausgegeben werden?

<p align="center">
<img src="while2.png" alt="While-Schleife-Beispiel" width="25%">
</p>

Können Sie obiges Bild als Code darstellen?

```java
class WhileBeispiel{
    public static void main(String args[]){

       
    }
}
```
@LIA.java(WhileBeispiel)

**Die "ewige" while-Schleife**

Bei der ewigen while-Schleife wird die while-Anweisung  solange wiederholt, bis die Bedingung ´false´ liefert. Dieser Fall tritt hier jedoch nie ein, so dass das Programm immer weiter läuft.

<p align="center">
<img src="ewigeWhile.png" alt="ewige While-Schleife" width="20%">
</p>


**Anmerkungen**

- Die Bedingung der `while`-Schleife wird vor der Ausführung des Codeblocks überprüft. Wenn die Bedingung falsch ist, wird der Codeblock nicht ausgeführt und die Schleife wird beendet.
- Es ist wichtig, sicherzustellen, dass sich die Bedingung im Verlauf der Schleife ändert, um eine Endlosschleife zu vermeiden.
- `break` kann verwendet werden, um die Schleife vorzeitig zu beenden, und `continue` springt zum nächsten Schleifendurchlauf.

Die `while`-Schleife ist besonders nützlich, wenn die Anzahl der Iterationen im Voraus nicht bekannt ist, sondern von einer Bedingung abhängt.



### Übungen

**Aufgabe 1:**  
Berechnen Sie die Summe aller Zahlen von 0 bis zu einer vorgegebenen größten Zahl. Für das Beispiel 5 wäre das also 0+1+2+3+4+5 = 15.

Lösen Sie das Problem auf mindestens drei verschiedene Arten. 

**Weitere Aufgaben:**   Machen Sie die Aufgaben aus der [Aufgaben-Datenbank](https://speiser.hft-pages.io/programmieraufgaben/2024-ss-pro-1/) aus Kapitel 02.




### Ablage 

Wann wird welche Schleife verwendet?

* while -> Anzahl Durchläufe ist zu Beginn unbekannt
* for -> Anzahl Durchläufe ist zu Beginn bekannt	
* for each -> Zugriff auf die Elemente einer Menge
* do-while -> Anzahl Durchläufe ist zu Beginn unbekannt, aber ein Durchlauf ist mindestens notwendig


## Arrays

Schauen Sie sich folgenden Code an und überlegen Sie sich folgende Fragen, bevor Sie weiterlesen:

- Was passiert hier? Gehen Sie den Code durch und versuchen Sie diesen nachzuvollziehen!
- Welches Anwendungsszenario könnte hier wiedergegeben sein?
- Worin bestehen die Vor- und Nachteile in diesem Code?


```java
class Arrays{
    public static void main(String args[]){
        int wpmMo = 55;
        int wpmDi = 57;
        int wpmMi = 49;
        int wpmDo = 63;
        int wpmFr = 0;
        int wpmSa = 56;
        int wpmSo = 70;

        int sum = 0;
        sum += wpmMo;
        sum += wpmDi;
        sum += wpmMi;
        sum += wpmDo;
        sum += wpmFr;
        sum += wpmSa;
        sum += wpmSo;

        int avg = sum / 7;
        System.out.println(avg);
    }
}
```
@LIA.java(Arrays)

Ein mögliches Anwendungsszenario könnte sein:

Sie haben gemessen, wie schnell Sie Java-Code tippen können und sind dabei wie folgt vorgegangen:

- Täglich üben und `wpm` messen
- Wert in einer Variable für diesen Tag eintragen
- Summe über alle Tages-Variablen bilden
- Durchschnitt berechnen

Sie können dies selbst ausprobieren. Gehen Sie auf [Speedtyper](https://www.speedtyper.dev/) und testen Sie Ihre Tippgeschwindigkeit. Absoliveren Sie diese Übung immer wieder, um sich zu verbessern.

Doch nun zurück zum Code: Das ist ziemlich repetetiv, denn neben der vielen Tipparbeit ist das auch noch:

- Fehleranfällig: einen Tag vergessen, einen Tag doppelt nehmen
- Unflexibel: was ist, wenn wir länger als exakt eine Woche üben?

Für sich wiederholende Berechnungen haben wir bereits die Schleife kennengelernt. Dabei konnten wir z.B. einen Zähler hochzählen. Wiederholen Sie: Was passiert hier?

```java
class SchleifeWiederholung{
    public static void main(String args[]){
        int zaehler = 0;
        while(zaehler < 7) {
            System.out.println(zaehler);
            zaehler++;
        }
    }
}
```
@LIA.java(SchleifeWiederholung)

Mit Arrays gibt es eine Datenstruktur, bei der wir mit Hilfe eines solchen Zählers auf verschiedene Variablen zugreifen können. Statt einzelne Variablen für jeden Tag anzulegen, speichern wie die `wpm` nun besser in einem Array:

```
int[] wpm = {55, 57, 49, 63, 0, 56, 70};
```

Im Speicher wird Platz für 7 direkt hintereinanderliegende `int`-Werte reserviert und befüllt:

<!-- data-type="None" -->
| Index  | 0 | 1 | 2 | 3 | 4 | 5 | 6 |
|:-------|---|---|---|---|---|---|---|
| Wert   | 55| 57| 49| 63| 0 | 56| 70|


Ein Array mit 7 Elementen, kann man sich in etwa so vorstellen: 

<p align="center">
<img src="array-1.png" alt="Array" width="55%">
</p>

Unser konkretes Array sieht dann so aus:

<p align="center">
<img src="array-2.png" alt="Array befüllt" width="45%">
</p>

Mit Hilfe des Index können wir auf die Werte zugreifen:

```
// Der Wert für Montag ist der erste Wert - wir fangen immer bei 0 an zu zählen
wpm[0];
```

Variablen vom Array-Typ haben eine  `.length`-Eigenschaft, die angibt wie viele Werte vorhanden sind:

```
wpm.length
```

Nun können wir eine Schleife verwenden, um den Mittelwert zu bilden:

```java
class Mittelwert{
    public static void main(String args[]){
        int i = 0;
        int sum = 0;
        int[] wpm = {55, 57, 49, 63, 0, 56, 70};
            while(i < wpm.length) { // < statt <= weil wir bei 0 anfangen zu zählen
                sum += wpm[i];
                i++;
            }
        int avg = sum / wpm.length; // Durch Verwendung von .length statt 7 sind wir flexibel
        System.out.println("Der Durchschnitt ist: " + avg);
    }
}
```
@LIA.java(Mittelwert)

* Versuchen Sie diesen Code nachzuvollziehen. 

* Erstellen Sie nun ein eigenes Programm, in welchem Sie ein Array der Länge 10 mit beliebigen Werten befüllen und die Werte des Array dann aufsummieren. Nutzen Sie hierfür eine geeignete Schleife. Geben Sie die Summe anschließend auf der Konsole aus.

### Arrays: Basics


**Datentyp von Arrays**

Der Datentyp eines Arrays ergibt sich aus dem Basisdatentyp (der Datentyp jedes einzelnen Elements) mit angehängten eckigen Klammern `[]`, also z.B.
`int[], double[], boolean[], char[]`.

**Initialisierung von Arrays**

Arrays müssen immer initialisiert werden, sonst passiert sowas:

```java
class ArrayKaputt{
    public static void main(String args[]){
        int[] meinArray;
        System.out.println(meinArray);
    }
}
```
@LIA.java(ArrayKaputt)


Initialisieren können wir entweder mit Werten/Literalen, wie oben bei `wpm` oder z.B.:

```
char message[] = {'H', 'a', 'l', 'l', 'o'};
```

Oder per Schlüsselwort `new` - hier wird Speicher reserviert aber keine Werte hinterlegt:

```
double[] tagesTemperaturen2022 = new double[365];
```

Die Größe lässt sich nicht nachträglich nicht mehr ändern (hier 365).

<br>

Auf einzelne Werte wird per Zahl zugegriffen:

```
message[1] //wäre in dem Fall der Buchstabe a
```

Eine einzelne Position im Array verhält sich wie eine Variable - letztendlich lässt sich über die Adresse des Arrays, den Index und die Größe jedes Elements ja auch die Speicheradresse ermitteln. Somit kann ein Arrayzugriff auch links vom Zuweisungsoperator `=` stehen:

```
tagesTemperaturen2022[30] = 8.5;
```

Die Anzahl der Element im Array `a` ergibt sich mit `a.length`. Niemals nehmen wir ein Literal mit der aktuellen Länge! Das erste Element befindet sicht immer an Position 0. Somit ist das letzte Element an Position `length - 1`:

```
message[message.length - 1]
```

**Ausgabe von Arrays**

Es gibt verschiedene Möglichkeiten, Arrays auszugeben. Eine davon, die Ihnen bereits bekannt ist, ist diese:

```
int [] liste = {0, 1, 2};		
System.out.println(liste[0]);	
System.out.println(liste[1]);	
System.out.println(liste[2]);
```
Diese Methode ist jedoch nicht besonders effizient. Daher verwenden wir Schleifen, um die Effizienz zu verbessern:

```
int zaehler = 0;
while (zaehler < 3) {
    zaehler++;
}
```

Durch die Kombination des Arrays mit einer Schleife erhalten wir dann folgende Ausgabe:

```
int [] liste = {0, 1, 2};
int zaehler = 0;
while (zaehler < 3) {
    System.out.println(liste[zaehler]);
    zaehler++;
}
```

**Übung**
Versuchen Sie nun die obigen Erkenntnisse in ein lauffähiges Programm zu packen.

```java
class MeinArray{
    public static void main(String args[]){
        
        
    }
}
```
@LIA.java(MeinArray)

### Wachsende Arrays (für IF relevant)

* Arrays werden bei der Erzeugung mit fester, nicht mehr änderbarer Größe erzeugt
* Möchten man die Größe eines Array-Objektes nachträglich ändern, so muss neues Array-Objekt erzeugt werden und das
bisherige Array in das neue Array umkopiert werden 
* Diese Aktionen werden von der Standardfunktion `copyOf` effizient erledigt
* Die Klasse `java.util.Arrays` enthält zahlreiche Funktionen zur Manipulation von Arrays wie z.B. das eben erwähnte `copyOf`

**Hintergrund:** 
In Java gibt es bereits sehr, sehr viele vorgefertigte Methoden, die wir nutzen können. Erklärungen hierzu finden Sie unter: [Java API](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/module-summary.html). Mit diesem Link werden wir das kommende Jahr sehr viel arbeiten. 
Unter java.util finden Sie die Klasse `Arrays`, die Methoden zum Manipulieren von Arrays enthält. So auch das oben genannte `java.util.Arrays`

* Welche Länge hat in folgendem Code welches Array?
* Was ist die Ausgabe der Schleife?

```java
import java.util.Arrays; // durch die Importanweisung wird die genutzte Methode gefunden
class ArrayKopie{
    public static void main(String args[]){
        int[] meinArray = {0,1,2,3,4,5};
        int[] neuesArray = Arrays.copyOf(meinArray,meinArray.length*2);
        
        System.out.println("Länge Array: " + meinArray.length);
        System.out.println("Länge neues Array: " + neuesArray.length);

        for(int i:neuesArray) {
        	System.out.println(i);
        }       
    }
}
```
@LIA.java(ArrayKopie)

* Mit der Methode `arraycopy` der Klasse `System` können Sie die Kopie noch genauer steuern:

```java
class ArrayKopie2{
    public static void main(String args[]){
        int[] meinArray = {0,1,2,3,4,5};
        int[] neuesArray = new int[meinArray.length*2];
        System.arraycopy(meinArray, 0,neuesArray, 0,meinArray.length);
        for(int i : neuesArray) {
        	System.out.println(i);
        }   
    }
}
```
@LIA.java(ArrayKopie2)

* Suchen Sie die Methode `arraycopy` in der Java API und finden Sie heraus, was die Argumente in der Methode bedeuten. 
* Ändern Sie die Argumente ab und schauen Sie sich das ergebnis an. 

Hinweis: die Argumente einer Methode sind die Parameter, die in den Klammern der Methode stehen. Methoden lernen wir bald genauer kennen. 

Lösungshinweis: Sie finden die Methode im Module `java.base`, im Paket `java.lang` und im Klassensystem unterhalb von `java.lang.Object`.


### Mehrdimensionale Arrays

Arrays können auch mit mehrdimensionalen Indizes gebaut werden - in Java sind das technisch gesehen Arrays mit einem weiteren Array als Basisdatentyp. Beispiele für Anwendungen:

- Tabellen, z.B. Stundenplan mit Tagen als Spalten und Vorlesungsblöcken als Zeilen und Vorlesungsbezeichnung
- Bilder - 2 dimensionale Anordnungen von Pixel (Farbwerten)
- Welten in Computerspielen: zwei- oder dreidimensionale Anordnungen von Feldern

Durchwandern können wir diese Arrays mit geschachtelten Schleifen.

Ein zweidimensionales Array kann auch wieder per Literale oder per `new` konstruiert werden. 

Machen Sie sich mit folgendem Coding vertraut:

```java
class Tabelle{
    public static void main(String args[]){
		int[][] tabelle = 	{{11, 12, 13},
							{21, 22, 23},
							{31, 32, 33}};

		System.out.println(tabelle[1][2]);
    }
}
```
@LIA.java(Tabelle)

* Welches Element wird hier ausgegeben? 
* Schreiben Sie eine doppelte Schleife, so dass alle Elemente ausgegeben werden.

Hier finden Sie zwei weitere Beispiele: 

```
// 5x5 Array mit true (Schwarz) / false (Weiss) Werten
boolean[][] schwarzweissBild = {{false, false, true, false, false}, 
                                {false, true, false, true, false},
                                {true, true, true, true, true},
                                {true, false, false, false, true},
                                {true, true, true, true, true}};

// Array für Klausurpunkte
int nStudierende = 30;
int nAufgaben = 10;
int[][] punkte = new int[nStudierende][nAufgaben];
```

### Übungen

**Weitere Aufgaben: **  Machen Sie die Aufgaben aus der [Aufgaben-Datenbank](https://speiser.hft-pages.io/programmieraufgaben/2024-ss-pro-1/) aus Kapitel 03.


## Strings


Bisher haben wir uns mit primitiven Datentypen befasst, wie z.B. int, double und char, um einfache Werte zu speichern. Mit dem primitiven Datentyp char können wir einzelne Zeichen speichern, während ein char-Array Zeichenfolgen einer festen Länge speichern kann.

Für die Arbeit mit Zeichenketten bietet Java die Klasse `String` an. Im Gegensatz zu primitiven Datentypen stellt die Klasse `String` einen Referenztyp dar. Das bedeutet, dass eine Variable vom Typ `String` nicht den tatsächlichen String selbst speichert, sondern eine Referenz auf das `String`-Objekt in der Speicherstruktur.

Objekte eines Referenztyps, wie z.B. String-Objekte, können Methoden bereitstellen, die auf sie angewendet werden können. Die `String`-Klasse stellt eine Vielzahl von Methoden zur Verfügung, um Zeichenketten zu manipulieren, vergleichen, suchen und mehr.

Was passiert in folgendem Programm? 

* Versuchen Sie das Programm nachzuvollziehen.
* Welche Ausgaben erscheinen auf der Konsole?
* Wie wurden die einzelnen Strings gebaut?

```java
class StringBeispiel{
    public static void main(String args[]){
        String name_1 = new String("Speicherfresser"); 
        String name_2 = "String-Pool"; 
        char[] buchstaben = { 'E', 'i', 'n', 'z', 'e', 'l', 'n'};
        String name_3 = new String(buchstaben); 
        String name_4 = "Bau" + "meister"; 

        System.out.println(name_1);  
        System.out.println(name_2); 
        System.out.println(name_3); 
        System.out.println(name_4); 
    }
}
```
@LIA.java(StringBeispiel)



### Nutzung von Zeichenketten

Wir schauen uns in diesem Kapitel etwas genauer an, wie Strings erzeugt werden und wo diese gespeichert werden.

- Mit dem Konstruktoraufruf `new String(…)` werden immer neue Stringobjekte angelegt.

- `String`-Literale (Zeichenketten in doppelten Anführungszeichen) werden im String-Pool verwaltet.

- Alle Java-Objekte werden auf dem Speicherbereich namens Heap angelegt

Merke: Die Objekterzeugung mit `new()` umgeht den String-Pool

Beachten Sie dabei folgende Abbildung. Versuchen Sie diese nachzuvollziehen. Wo wird welcher String gespeichert?

![](zeichenketten_1.JPG)

Schauen Sie das einführende Programm erneut an. Können Sie nun die Kommentare nachvollziehen?

```java
class StringBeispiel{
    public static void main(String args[]){
        String name_1 = new String("Speicherfresser"); // new belegt neuen Speicherplatz
        String name_2 = "String-Pool"; // Zeichenkettenkonstaenten werden wiederverwendet

        char[] buchstaben = { 'E', 'i', 'n', 'z', 'e', 'l', 'n'};
        String name_3 = new String(buchstaben); // new belegt neuen Speicherplatz

        String name_4 = "Bau" + "meister"; // Einzelteile werden wiederverwendet,
                                        // aber + Operator erzeugt neues Objekt
        System.out.println(name_1); //Ausgabe: Speicherfresser 
        System.out.println(name_2); //Ausgabe: String-Pool
        System.out.println(name_3); //Ausgabe: Einzeln
        System.out.println(name_4); //Ausgabe: Baumeister
    }
}
```
@LIA.java(StringBeispiel)

**Unveränderbare Zeichenketten**

Objekte der Klasse `String` sind unveränderlich.

- Methoden, die einen String ändern, liefern ein neues Objekt zurück.
- Beispiel: Methode replace()
- Versuchen Sie nun auch folgenden Code nachzuvollziehen, welche Ausgaben werden generiert?

```java
class StringLaeufer{
    public static void main(String args[]){
        String schachFigur = "Läufer";
        String jemandDerVielLaeuft = "Läufer";
        System.out.println(schachFigur == jemandDerVielLaeuft); 
        schachFigur.replace("Läufer", "König"); // Das Objekt, auf das schachFigur zeigt, bleibt unverändert

        System.out.println(schachFigur); 
        System.out.println(jemandDerVielLaeuft); 
        System.out.println(schachFigur == jemandDerVielLaeuft); 
        schachFigur = schachFigur.replace("Läufer", "König"); // Die Variable schachFigur zeigt auf ein anderes Objekt
        System.out.println(schachFigur); 
        System.out.println(schachFigur == jemandDerVielLaeuft); 
    }
}
```
@LIA.java(StringLaeufer)

### Veränderbare Zeichenketten

- Objekte der Klassen StringBuffer und StringBuilder sind veränderbar. Analysieren Sie folgendes Beispiel:

```java
class StringBilder{
    public static void main(String args[]){
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append("String"); //append() und insert() verändern dynamisch das darunterliegende Objekt
        stringBuilder.append("-");
        stringBuilder.append("Bilder");
        stringBuilder.insert(8, "u");
        System.out.println(stringBuilder.toString());
    }
}
```
@LIA.java(StringBilder)


- Die Objekte können dynamisch ihre Größe ändern.
- Optional kann man im Konstruktor der Klassen StringBuffer und StringBuilder bereits eine Größe mitgeben.

- Die Klassen StringBuffer und StringBuilder bieten die gleichen Methoden an.
- Die beiden Klassen unterscheiden sich in der Arbeitsweise:

    - StringBuffer ist synchronisiert (= Thread-sicher bei zeitgleichem Zugriff mehrerer Programmteile)

  - StringBuilder ist nicht synchronisiert (und etwas schneller)
- Weitere Methoden

    - delete(), deleteCharAt()

  - replace()

  - usw.



### Zeichenkettenoperationen

Beispiel:

```
String satz = „Dies ist ein Satz.“;
```

Was für Methoden können auf diesem String aufrufen werden? 

Methoden: charAt(int index), length(), substring(int beginIndex) etc.

- Zugriff auf ein Zeichen: charAt()
- Länge eines Strings: length()
- Zerlegen eines Strings: substring(), split()

```java
public class Zeichenkettenoperationen {
    public static void main(String[] args) {
        String satz = "Das ist ein Satz";
        String[] woerter = satz.split(" "); //Teilt den String bei allen Leerzeichen
        for(int i = 0; i < woerter.length; i++) {
            System.out.println(woerter[i]);
        } 

        String teil = satz.substring(6, 10); //Beginn des Substrings an Position 6 und Ende an Position 10
        System.out.println(teil);
   }
}
```
@LIA.java(Zeichenkettenoperationen)

- Vergleichsoperationen in Java funktionieren nur für primitive Datentypen und nicht für Referenztypen wie z.B. String
- Zeichenketten vergleicht man mit `equals()`, nicht mit == !!!
- Wenn Teile von Strings verglichen werden sollen, kann man z.B. `endsWith()`, `startsWith()` oder `regionMatches()` verwenden
- Mit `indexOf()`, `lastIndexOf()`, `contains()` kann man in Strings suchen
- Veränderungen können mit `replace()`, `replaceFirst()`, `replaceAll()` erfolgen

**Aufgabe**

Suchen Sie sich geeignete Methoden in der Java API der Klasse [String](https://docs.oracle.com/en/java/javase/21/docs//api/java.base/java/lang/String.html)
um den String "Iss" jeweils geeignet weiter zu verarbeiten. Dabei sollte jeweils das Wort im Kommentar erscheinen.

```java
public class Iss {
    public static void main(String[] args) {
        String satz = "Iss";
        // Eis

        // Heiss

        // Heisser

        //Hosenschei**er
   }
}
```
@LIA.java(Iss)


**Weitere Beispiele**

Versuchen Sie nun auch folgenden Code nachzuvollziehen. Welche Ausgaben werden generiert und warum?

```java
class StringWeiteresBeispiel{
    public static void main(String args[]){
        String wort = "Urinstrinkt";
        boolean sindGleich = wort.equals("Ur" + "instinkt");
        System.out.println(sindGleich); 

        System.out.println(wort.startsWith("Urin")); 
        System.out.println(wort.endsWith("stinkt")); 

        System.out.println("Autoschlüssel".regionMatches(5, "Schlüsselbund", 1,3)); 
        System.out.println(wort.indexOf('i')); 
        System.out.println(wort.lastIndexOf('i')); 
    }
}
```
@LIA.java(StringWeiteresBeispiel)

### Übungen

Machen Sie die Aufgaben aus der [Aufgaben-Datenbank](https://speiser.hft-pages.io/programmieraufgaben/2024-ss-pro-1/) aus Kapitel 04.


## Exkurs: Debugging (WIP)

TODO: EF


## Klassen, Objekte, Methoden


## Exkurs: Rekursion (WIP)

* Eine Rekursion ein Objekt oder ein Vorgang, der sich selbst als Teil enthält oder mithilfe von sich selbst definierbar ist. 
Eine rekursive Funktion ist somit eine Funktion, die sich selbst aufruft.
* Rekursion kann anstelle von Schleifen genutzt werden

**Beispiel: Fakultät**

* Wie wird die Fakultät berechnet? Recherchieren Sie zwei verschiedene Berechnungsmöglichkeiten.
* Sind Ihre gefundenen Berechnungsmöglichkeiten rekursiv oder iterativ?

### Fakultät


Eine iterative Berechnungsmöglichkeit der Fakultät:

![Iterative Berechnung Fakultät](fakultaetIterativ.png)

Versus eine rekursive Berechnungsmöglichkeit der Fakultät:

![Rekrusive Berechnung Fakultät](fakultaetRekursiv.png)

So kann man sich die rekursive Berechnung vorstellen.
![Fakultätsberechnung](fakultaet.png)

Achtung:

Es darf keine unendliche Rekursion entstehen. D.h. Sie brauchen eine Abbruchbedingung. Ansonsten führt dies zu einem Laufzeitfehler. Der rekursive Funktionsaufruf erfolgt nur, wenn die Abbruchbedingung nicht erfüllt ist

Hier ein Mustercode für die Rekursion: 

```java
public static typ funktion(typ parameter){
  if (bedingung){return ergebnis;
  }else{return wert op funktion(neuerParameter);
  }
}
```

* Rekursion führt für bestimmte Problemstellungen zu prägnanten, knappen und eleganten Algorithmen.
* Rekursionen verbrauchen meist mehr Arbeitsspeicher. Deshalb kann durch zu große Rekursionstiefe auch ein Stack Overflow entstehen.

**Aufgabe**

Vervollständigen Sie die beiden Programme, so dass jeweils die Fakultät berechnet wird:

```java
class FakultaetIterativ{
    public static void main(String args[]){
        int n = 4;
        System.out.println(n + "! = " + fakultaet(n));
    }

    public static int fakultaet(int n ){
        int fakultaet = 1;

        // Fügen Sie hier den passenden Code ein

        return fakultaet;
    }
    
}
```
@LIA.java(FakultaetIterativ)


```java
class FakultaetRekursiv{
    public static void main(String args[]){
        int n = 4;
        System.out.println(n + "! = " + fakultaet(n));
    }

    public static int fakultaet(int n ){
        if ( // Bedingung? ){
            return // was wird zurück gegeben bei Abbruchbedingungen?
        } else {
            // was wird zurück gegeben? rekursiver Aufruf 
    }
}
```
@LIA.java(FakultaetRekursiv)

### Übung
TODO: Bionomi rekursiv
Zahlensumme rekursiv -> Debug-Perspektive

## Vererbung
## Abstrakte Klassen, Interfaces
## Collections & Maps
## Exceptions
## Generics (optional)
