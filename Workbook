<!--
author: Melanie Baur
language: de
version: 0.0.4
narrator: Deutsch Female
mode: Textbook

comment: Vorlesung Programmieren 1 an der HFT Stuttgart, content adaptiert von Sebastian Speiser und weiteren Professoren und Hiwis der HFT Stuttgart

import: https://raw.githubusercontent.com/liascript/CodeRunner/master/README.md

-->
# Programmieren 1 in Java
<article>
Dieses Online-Buch wird entwickelt an der Hochschule für Technik Stuttgart und dient der Einführung in die Programmierung mit Java zunächst in den Studiengängen Informatik und Wirtschaftsinformatik im 1. Semester. Es werden somit keine Vorkenntnisse im Programmieren vorausgesetzt. Das Buch befindet sich gerade im Aufbau und wird laufend ergänzt und verbessert.

Als Arbeitsweise wird für die Teilnehmenden der oben genannten Vorlesungen vorgeschlagen, jede Woche ein Kapitel durchzuarbeiten inkl. der zur Verfügung stehenden Programmieraufgaben. Der geschätze Zeitaufwand beträgt ohne Vorkenntnisse pro Woche 16 Stunden. Hiervon werden 6 Stunden an der Hochschule erbracht, ein:e Professor:in und/oder ein:e Assistent:in stehen hierbei für Fragen zur Verfügung. 10 Stunden sollen selbständig absolviert werden.

Lesen Sie gerne ein "echtes" Buch? So empfehlen wir die Lektüre von Philipp Ackermann: Schrödinger programmiert Java, Rheinwerk. Sie finden dieses Buch als eBook in der HFT Bibliothek.

Die wichtigsten Informationen finden Sie aber in diesem Online-Buch. Dieses besteht nicht nur aus Text, sondern auch aus Links zu externen Webseiten. Für diese übernehmen wir keinerlei Haftung. Weiterhin gibt es natürlich viele Code-Beispiele. Diese können Sie direkt im Online-Buch ausführen. 

Zum Beispiel ist das folgende ein Programm-Code, bei dem etwas auf der Konsole ausgegeben wird.

```java
class HalloWelt{
    public static void main(String args[]){
        System.out.println("Hallo Welt");
    }
}
```
@LIA.java(HalloWelt)

Klicken Sie nun auf </> im kleinen Kreis unter der Code-Zeile, so wird der Code ausgeführt und Sie sehen im schwarzen Kästchen, das dann erscheint, das Ergebnis.

</article>

Natürlich sollen Sie nicht nur lesen, sondern insbesondere auch viel selbst machen. Hier kommt die erste Aufgabe.

**Aufgabe:**
Geben Sie nun statt "Hallo Welt" einen anderen Text zwischen den Anführungszeichen ein. Führen Sie den Code erneut aus. Was fällt Ihnen auf?

Auf der rechten Seiten unterhalb des Codes, können Sie nun mit den Pfeilen zwischen den verschiedenen Codes hin- und herwechseln. Gehen Sie mit dem Pfeil nach links zurück auf den ursprünglichen Code und dann mit dem Pfeil nach rechts wieder zu Ihrem neuen Code.


**Übungen:**
Um viel zu üben, denn das ist das wichtigste beim Programmieren, werden [hier](https://speiser.hft-pages.io/programmieraufgaben/2024-ss-pro-1/) zu jedem Kapitel Übungen bereit gestellt. Sie werden im Laufe des Buchs immer wieder zu diesen Übungen aufgefordert. Führen Sie die Aufgaben gewissenhaft aus. Bei Problemen fragen Sie einfach in der nächsten Mentoringstunde. 



## Einführung 
Eine Programmiersprache zu lernen, ist unabdingbare Voraussetzung für eine Tätigkeit in der Informatik, z.B. als Entwickler, Projektleiter, Softwarearchitekt, denn die Computer führen exakt den Code aus, den sie vorgesetzt bekommen und die Compiler übersetzen genau das was im Programmtext steht in Maschinencode. 

Sie als Programmierer:
* Analysieren Problemen
* Überlegen sich Lösungen
* Übersetzen Lösungen in Programmtext
Der Computer ist nicht kreativ und findet keine Lösungen. Dafür gibt es die glorreiche Tätigkeit des Programmierens.

Um dies zu können, müssen Sie viel üben:
* Kennen Sie einen Trainer der Bundesliga, der nicht Profi-Fußballer war? 
* Haben Sie Schwimmen oder Radfahren aus Büchern erlernt? 
* Sind Sie zur praktischen Fahrprüfung erstmals Auto gefahren?
* Wie viele Jahre hat ein Musiker vor dem ersten Klavierkonzert geübt?

Was könnte Beispiele für kleine Programme sein?

* Zwei Zahlen addieren
* Eine Zahl abspeichern
* Eine Zahl laden
* Zwei Zahlen miteinander vergleichen

Das können Sie sicherlich auch, aber Computer können das:
* Sehr schnell: Milliarden von Operationen pro Sekunde
* Sehr genau: Milliarden von Zahlen speichern und exakt so wieder abrufen

Sie lernen zunächst, was Code und was ein Programm ist. Am Ende des Kapitels werden Sie Ihr erstes eigenes Programm in der Programmiersprache Java schreiben und ausführen.



### Was ist Code?
* Code ist eine Reihe von Anweisungen,
* Jede Anweisung beschreibt, welche Operation (z.B. Addition) der Computer mit welchen Operanden (z.B. 5 und 3) ausführen soll
* Der Computer führt eine Anweisung nach der anderen aus

Programme bestehen nun aus Millionen von Anweisungen. Die Anweisungen sind wiederum Zahlen - hier als Hexadezimal-codierter x86-Code (erstellt mit [godbolt.org](https://godbolt.org/z/WYorj7EG5)):

```
55 48 89 e5
89 7d fc 8b
45 fc 0f c0
5d c3
```
    
So zu entwickeln ist sehr kompliziert und fehleranfällig, also gibt es ein Abstraktionsniveau höher Assembler - menschenmerkbare Abkürzungen für die Befehle und Hilfe bei der Berechnung von Speicheradressen, wo Daten abgespeichert sind, z.B.:

```
push   rbp
 mov    rbp,rsp
 mov    DWORD PTR [rbp-0x4],edi
 mov    eax,DWORD PTR [rbp-0x4]
 imul   eax,eax
 pop    rbp
 ret    
main:
 push   rbp
 mov    rbp,rsp
 mov    eax,0x0
 pop    rbp
 ret  
```

Auch dies ist noch recht aufwändig - und zudem noch an eine konkrete Prozessorarchitektur gebunden. Als nächstes Abstraktionsniveau kann man dann eine höhere Programmiersprache nehmen, z.B.:

```
int square(int num) {
    return num * num;
}
```

Wir nutzen in unserer Vorlesung Java als Programmiersprache. Im Hintergrund gibt es einen Compiler, der Java in Maschinensprache übersetzt. Die Maschinensprache wird auf unseren Wunsch hin vom Betriebssystem geladen und dann zur Ausführung gebracht. 
Bei Java gibt es noch die Besonderheit, dass es eine Art virtuelle Maschinensprache nutzt, die unabhängig von der genutzten Prozessorarchitektur ist und erst zur Laufzeit von einer weiteren Programmkomponente in die konkrete Maschinensprache übersetzt wird. 
Aber hierzu später mehr


**Welcher Code wird ausgeführt?**

Das Betriebssystem startet den binären Code bei der ersten Anweisung - aber wo ist das in unserem Code der höheren Programmiersprache?

Im allgemeinen Java-Programm: die Main-Methode der Hauptklasse: 

```
public static void main(String[] args) {
}
```


### Was ist Programmieren?
Unter Programmieren versteht man das Erstellen von Anweisungen für eine Maschine. Dies hat historisch eine viel längere Geschichte, als Sie wahrscheinlich vermuten. Besuchen Sie diese [Seite](https://www.cs101.com/) und überzeugen Sie sich selbst. 

Im Rahmen der nächsten zwei Semester werden Sie nun folgendes Lernen: 

* Programmieren 1: Erwerb der Fähigkeit, ein (mittelgroßes) Java-Programm zu schreiben
* Programmieren 2: Erweiterung um die „Kommunikation mit der Außenwelt“ und Einführung in die Web-Programmierung

Ein Programm ist vergleichbar mit einem Kochrezept:
Ziel ist es einen bzw. mehrere fertige Pfannkuchen aus verschiedenen einzelnen Zutaten zu kochen.
Kochrezepte sind wie „imperative“ Programmierung: (von lat. imperare: anordnen, befehlen)

```
\\ Variablen
gramm mehl        = 300;
liter milch       = 0,6;
stueck eier       = 3;
prise salz        = 1; 
liter wasser      = 0,05;
essloeffel butter = 1;

\\ Methoden
void rühren();
void braten();

\\Hauptprogramm
pfannkuchen_machen {
    teig = mehl + milch + eier + salz;
    rühren(teig);
    teig = teig + wasser;
    rühren(teig);
    pfannkuchen = braten(reig);
}
```

### Das erste Programm

Der Grundbaustein für ein Programm sind Anweisungen mit verschiedenen Untertypen:

1. Variablen deklarieren: Speicher für Daten reservieren
2. Variablen zuweisen: Werte oder Berechnungen im reservierten Speicher ablegen
3. Methodendeklarationen: eine bestimmte Sammlung von Anweisungen definieren, die unter einem Namen abgerufen werden kann, ggfs. mit Parametern
4. If-Anweisungen: Je nach Wert einer Bedingung, eine von mehreren Anweisungsblöcken ausführen
5. Schleifen: einen Anweisungsblock wiederholt ausführen

Aber nun erst einmal langsam, wir machen das Schritt für Schritt. 

**Aufbau eines Programms**

* Ein Java-Programm ist in (Klassen), Methoden und Blöcke aufgeteilt, die ineinander verschachtelt sind.
* Blöcke werden durch die {}-Klammern geschachtelt.
* Der äußere Block umfasst die Klasse `Uebung`, der innere Block bildet den Methodenrumpf von `main` mit dem Aufruf der Methode `tueWas`.


```
public class Uebung{
    public static void main(String args[]){
        tueWas(0815);
    }
}
```

Genauer: 

* Hauptklasse oder Startklasse: Oberste Struktureinheit in Java
* Hauptmethode oder main-Methode genannt: Hier läuft das eigentliche Programm ab, ohne die main-Methode läuft das Programm nicht.
* Weitere Methoden: Es können für Teilberechnungen weitere Methoden definiert werden, die dann von der main-Methode aufgerufen werden.
    
    * Methoden sind gespeicherte Anweisungen innerhalb eines Programms. Sie werden für einen bestimmten Zweck geschrieben und aufgerufen.
    * Methoden kann man auch als Werkzeug betrachten. Man kann ein Werkzeug besitzen, aber es gar nicht einsetzen. 



### Übersetzen und Ausführen eines Programms

* Java-Programme können mit einem beliebigen Editor geschrieben werden. Die Dateiendung der Quell-Dateien lautet .java. Hier steht der Quellcode (engl. source)
* Der Java-Compiler javac übersetzt die Quelldatei in sogenannten Bytecode, dieser wird in der mit der Endung .class gespeichert.
* Die Java-Laufzeitumgebung (engl. Runtime Environment) java führt den Bytecode aus.
* Das erste Java-Programm gibt den Text „Hello World“ am Bildschirm aus.


* Übersetzen: In Java wird Programmcode über einen Compiler in den Bytecode übersetzt (kompiliert). Dieser kann dann von einem Interpreter ausgeführt werden.


![Alt text](programmausfuehren.png)

* Eine Besonderheit von Java ist, dass ein Bytecode von verschiedenen Systemen verwendet werden kann: „Write once, run anywhere“

![Alt text](bytecode.png)

Wir wollen nun das Programm von der Einleitung selbst schreiben. Hierzu benötigen Sie wie das Bild zeigt: 
* Einen Java-Compiler
* Einen Java-Interpreter

Auf den Rechner in der Hochschule ist alles bereits installiert. 
Auf Ihrem eigenen Rechner können Sie auf die Schnelle einen externen Web-Editor nutzen, wie z.B. https://www.online-ide.com/online_java_editor.

Arbeiten Sie zu Hause das Kapitel der Installation durch, so dass Sie auch zu Hause programmieren können.

###  Installation


### Übungen
1) Recherchieren Sie ein Pfannkuchenrezept und versuchen Sie die einzelnen Schritte nachzuvollziehen. Natürlich dürfen Sie dieses Rezept auch nachkochen. 
2) Machen Sie die Aufgaben aus der [Aufgaben-Datenbank](https://speiser.hft-pages.io/programmieraufgaben/2024-ss-pro-1/) aus Kapitel 00.




## Variablen und Datentypen 

Schauen Sie sich folgendes Beispiel an und überlegen Sie sich für jede Zeile, was das Programm tun könnte und welche Ausgabe der Code Ihrer Meinung nach erzeugt.

```java
public class Variablen {
    public static void main(String[] args) {

        byte b = 1;
        System.out.println(b);

        short s = 250;
        System.out.println(s);

        int i = 5;
        System.out.println(i);

        long l = 105464560L;
        System.out.println(l);

        float f = 1.5f;
        System.out.println(f);

        double d = 1.8;
        System.out.println(d);

        char c = 'a';
        System.out.println(c);

        char c2 = 65;
        System.out.println(c2);

        boolean bl = true;
        System.out.println(bl);
    }
}
```
@LIA.java(Variablen)


* Führen Sie nun den Code aus und überprüfen Sie Ihre Vermutung. 

* Ändern Sie den Code ab und probieren Sie aus, ob das Programm noch läuft und was die Ausgabe ist. 

Achtung: Wenn Sie eine rote Ausgabe erhalten, haben Sie einen fehlerhaften Code erzeugt.Können Sie den Code wieder berichtigen?

* Gehen Sie nun auf die nächste Seite und arbeiten Sie die Erklärungen durch.


#### Variablen deklarieren
Der Speicher im Computer besteht nur aus einer langen Folge von 0en und 1en. Jeweils 8 werden zu einem Byte zusammengefasst. Die Bytes werden durchnummeriert (beginnend bei 0). Die Nummer eines Bytes ist dessen Adresse.

Variablen geben einer bestimmten Speicherstelle einen Namen und einen Typen:

* Einfacher zu merken als eine Speicheradresse
* Kann gleich bleiben auch wenn sich die Speicheradresse ändert
* Der Typ kann bestimmte Arten von Programmfehlern verhindern und bestimmt wie viele Bytes die Variable umfasst

Eine Variable ist also eine Art Gefäß im Speicher. Werte können überprüft, verändert und vor allem gespeichert werden.
Variablen haben einen bestimmten TYP, eine ADRESSE im Speicher, einem NAMEN und natürlich einem WERT. Java ist eine statisch typisierte Programmiersprache. Das bedeutet, dass jede Variable einen festen Typ hat, der bereits zur Übersetzungszeit bekannt ist (hierzu später mehr).

Wie funktioniert nun die Deklaration von Variablen in Java:

```
int schuhgroesse;  // Das hier ist übrigens ein Kommentar
char buchstabe1, buchstabe2, buchstabe3; // Hiervon braucht man oft mehrere
double temperatur; // Kommazahl
boolean sonnigerTag; // wahr/falsch, ja/nein -> boolean
```

In Java können wir Variablen direkt bei der Deklaration mit einem Wert initialisieren, hier *Literals* also Konstanten im Programmtext:

```
int schuhgroesse = 42;
double temperatur = 20.2; // Ohne Einheit - müssen wir uns separat merken
double wunschEinkommen = 50_000; // Euro? Brutto/Netto? Im Jahr oder Monat?
boolean sonnigerTag = true;
```

Allgemein also: 

```
Datentyp Variablenname = Wert;
```

Hinweis: Man muss einer Variable nicht sofot einen Wert geben. Dies kann auch später geschehen. Die Variable erhält dann zunächst einen Standardwert - je nach Datentyp. 


Hier finden Sie eine Übersicht über verschiedene primitive Datentypen, das sind die elementaren Datentypen:

| Datentyp   | Bit   | Minimum   | Maximum   |
| :--------- | :--------- | :--------- | :--------- |
| byte    | 8-Bit     | -128    | 127    |
| short    | 16-Bit     | -32768    | 32767    |
| int    | 32-Bit     | -2147483648    | 2147483647   |
| long    | 64-Bit     | -9223372036854775808    | 9223372036854775807    |
| float    | 32-Bit     | -3.4 * (10<sup>38</sup>)    | 3.4 * (10<sup>38</sup>)      |
| double    | 64-Bit     | -1.7 * (10<sup>308</sup>)    | 1.7 * (10<sup>308</sup>)    |

Weiterhin gibt es noch die beiden Datentypen `boolean` und `char`: 

| Datentyp   | Bit   |Werte   |
| :--------- | :--------- | :--------- | 
| boolean    | 1 Byte     | true / false   | 
| char    | 2 Byte     | Ein Unicode-Zeichen  | 

Primitive Typen werden immer klein geschrieben. 

Bei der Benennung von Variablen ist es wichtig, einige Regeln zu beachten:

* Am Anfang muss ein Buchstabe (oder `_`) stehen.
* Danach können Buchstaben oder Ziffern folgen.
* Erlaubt (aber nicht empfohlen) sind: `$, _, ä, ö, ü, ß, €, …` (wobei `$` oft für generierte Namen verwendet wird.)
* Nicht erlaubt sind Sonderzeichen wie `!, ?, *, /, … `
* Groß- und Kleinschreibung ist relevant. Das bedeutet, dass Variablennamen wie `glueckszahl` und `gluecksZahl` unterschiedlich sind.
* Variablennamen sollten zusammengeschrieben werden, also ohne Leerzeichen.
* Eine häufige Konvention ist die Verwendung von „CamelCase“:
  * Variablen, Methoden und Pakete beginnen klein und jedes neue Wort beginnt groß, z.B. kleinAnfangenUndJedesWortGrossBeginnen.
  * Klassennamen beginnen groß und jedes neue Wort beginnt groß, z.B. GrossAnfangenUndJedesWortGrossBeginnen.


#### Variablen zuweisen: Ausdrücke
Die Initialisierung hat den Variablen direkt bei der Speicherreservierung einen Wert zugewiesen. Nachdem eine Variable angelegt wurde können wir ihr einen (neuen) Wert zuweisen:

```
temperatur = 18.7;
```

Das ist eine Zuweisungs-Anweisung. Links vom Gleichheitszeichen steht der Name einer bereits deklarierten Variable. Rechts vom Gleichheitszeichen steht ein Ausdruck.

Für Ausdrücke gibt es verschiedene Aufbauten:

* Literale - das sind konstante Werte, die direkt im Programmtext geschrieben werden, z.B. `8`, `17.4`, `'a'`, `"Hallo Welt"`
* Variablen - der Name einer bestehenden Variable, dieser wird bei der Auswertung des Ausdrucks mit dem aktuellen Wert der Variable ersetzt, z.B. `schuhgroesse`
* Methodenaufrufe - siehe unten. Es wird Code, der unter dem Methodennamen abgespeichert ist ausgeführt und das Ergebnis zurück geliefert, z.B. `readInt()`, manche Methoden nehmen Parameter (wiederum Ausdrücke), z.B. `System.out.println("Hallo Welt")`
* Operationen: hier werden eine oder mehrere (meistens zwei) Ausdrücke mit einem Operator verknüpft, z.B. `schuhgroesse + wunschEinkommen`

In Java müssen wir den Wert eines Ausdrucks einer Variable zuweisen:

```
double komischeZahl = schuhgroesse + wunschEinkommen;
```
oder uns per Methodenaufruf ausgeben:
```
System.out.println("Hallo " + "Programmieren " + 1)
```
Mit Operationen und Methodenaufrufen können komplexe Ausdrücke geschafften werden, z.B.:
```
System.out.println("In Fahrenheit: " + ((readDouble() * 9.0/5.0) + 32))
```
Auch dazu später mehr.

Ausdrücke werden von innen nach außen ausgewertet, d.h. bei verschachtelten Ausdrücken erst die Sachen in Klammern, bzw. nach Prioritäten ("Punkt vor Strich).

Bei Zuweisungen wird erst die rechte Seite berechnet und dann erst die links genannte Variable aktualisiert:

```
int wert = 10;
wert
```

```
wert = wert + 1;
wert
```

#### Operatoren
Übersicht über wichtige Java-Operatoren:

| Operator | Beschreibung                                    |
|----------|-------------------------------------------------|
| +        | Addition von Zahlen oder Verkettung von Strings |
| -        | Subtraktion von Zahlen                          |
| *        | Multiplikation von Zahlen                       |
| /        | Division von Zahlen                             |
| %        | Modulo (Rest bei der Division)                  |
| +=       | Addition und Zuweisung                          |
| -=       | Subtraktion und Zuweisung                       |
| ++       | Inkrement (Erhöhung um eins)                    |
| --       | Dekrement (Verminderung um eins)                |


Von den Standardoperatoren `+`, `-`, `*` (Mal), `/` (geteilt durch) für Zahlen gibt es auch jeweils eine Version, die gleich die Zuweisung integriert, z.B.:

```
int x = 5;
x += 5; // Gleichbedeutend mit x = x + 5
x // Hier wäre x = 10
```

```
int y = 2;
y *= y; // Gleichbedeutend mit y = y * y;
y // Hier wäre y = 4
```
Häufig zählen wir Variablen um eins nach oben oder eins nach unten, hier gibt die Kurzformen `i++` und `i--`. Sie liefern den Wert von `i` zurück und danach wird `i` inkrementiert bzw. dekrementiert:

```
int i = 0;
System.out.println(i++); // Gibt 0 aus und erhöht dann i auf 1
System.out.println(i); // Gibt den neuen Wert von i (1) aus
System.out.println(i--); // Gibt 1 aus und verringert dann i auf 0
System.out.println(i); // Gibt den neuen Wert von i (0) aus
```

Weniger verbreitet sind die Formen `++i` und `--i`, die zuerst `i` inkrementieren bzw. dekrementieren und dann den Wert zurückliefern:

```
int i = 0;
System.out.println(++i); // Erhöht i zuerst auf 1 und gibt dann 1 aus
System.out.println(i); // Gibt den aktuellen Wert von i (1) aus
System.out.println(--i); // Verringert i zuerst auf 0 und gibt dann 0 aus
System.out.println(i); // Gibt den aktuellen Wert von i (0) aus
```

Überraschend nützlich ist der Modulo-Operator `%` - er liefert den Rest bei einer Ganzzahlendivision, z.B.:

```
int zahl = 22;
int divisor = 4;
int rest = zahl % divisor;
rest // Der Wert ist 2, da 22/4 = 5 Rest 2 ist
```

Weitere Operatoren sind Vergleichsoperatoren (`==`, `!=`, `<=`, `>=`, `<`, `>`), Bit-Operatoren (`&`, `|`, `<<`, `>>`) und logische Operatoren (`&&`, `||`)

### Übungen

* Führen Sie folgendes Quiz durch und testen Sie Ihr Wissen: 


**Frage 1**

Welcher Variablentyp würde am besten verwendet werden, um die Temperatur `42,2` Grad zu speichern?

[( )] Integer
[(x)] Float
[( )] String
[( )] Boolean

---

**Frage 2**

Welcher Variablentyp wird verwendet, um einzelne Buchstaben zu speichern?

[(x)] Char
[( )] Integer
[( )] Float
[( )] String

---

**Frage 3**

Welcher Variablentyp könnte verwendet werden, um alle Menschen auf der Welt zu nummerieren?

[( )] Char
[( )] Float
[(x)] Long
[( )] Integer

---

**Frage 4**

Welcher Variablentyp wird verwendet, um einen Satz zu speichern?

[( )] Char
[( )] Integer
[( )] Float
[(x)] String

*  Machen Sie die Aufgaben aus der [Aufgaben-Datenbank](https://speiser.hft-pages.io/programmieraufgaben/2024-ss-pro-1/) aus Kapitel 01.



## Kontrollflusss

Der Kontrollfluss in Java ermöglicht es uns, den Ablauf unseres Codes zu steuern, indem wir Entscheidungen treffen und Schleifen verwenden. Kontrollflussstrukturen wie bedingte Anweisungen und Schleifen ermöglichen es uns, unseren Code dynamisch zu gestalten und verschiedene Pfade je nach Bedingungen oder Anforderungen auszuführen.

```java
class Demo{
    public static void main(String args[]){
        int zahl = 10;

        if (zahl % 2 == 0) {
            System.out.println(zahl + " ist eine gerade Zahl.");
        } else {
            System.out.println(zahl + " ist eine ungerade Zahl.");
        }
        
        System.out.println("Zahlen von 1 bis 5:");
        for (int i = 1; i <= 5; i++) {
            System.out.println(i);
        }
    }
}
```
@LIA.java(Demo)

### If-Verzweigung
Die if-Anweisung ist die einfachste Kontrollstruktur:

```
if (Bedingung) {
    //Wenn die Bedingung `true` ist
    Anweisung;
}
```

Ist die Bedingung wahr, werden die Anweisungen der nächsten Zeile, bzw. des Blockes ausgeführt, ansonsten passiert nichts!

Beim Auswerten der Bedingung muss ein Boolescher Wert entstehen.

**Wie können diese Bedingungen aussehen?**

In Programmiersprachen werden häufig Vergleiche zwischen Werten mittels Operatoren durchgeführt, um Bedingungen zu überprüfen. Hier sind einige gängige Vergleiche:

- `a > 0`: Überprüft, ob der Wert von "a" größer als 0 ist.
  
- `c == d`: Überprüft, ob der Wert von "c" gleich dem Wert von "d" ist, zum Beispiel, ob zwei Ganzzahlen gleich sind.
  
- `e != 1`: Überprüft, ob der Wert von "e" ungleich 1 ist.
  
- `"Müller".equals("Meier")`: Überprüft die Gleichheit von zwei Strings, in diesem Fall, ob der String "Müller" gleich dem String "Meier" ist.

Diese Bedingungen können in `if`-Schleifen verwendet werden, um Entscheidungen im Code zu treffen. Zum Beispiel:

```
if (f > 5) {
    // Führe diesen Codeblock aus, wenn "f" größer als 5 ist
}
```
**Logische Operatoren können wie folgt aussehen:**

| Operator | Beschreibung                                                                                        |
|----------|-----------------------------------------------------------------------------------------------------|
| !        | Negation: Dreht den Wahrheitswert um (aus `true` wird `false` und aus `false` wird `true`)      |
| &        | Und mit vollständiger Auswertung: Liefert `true`, wenn beide Ausdrücke `true` sind               |
| \|       | Oder mit vollständiger Auswertung: Liefert `true`, wenn einer oder beide Ausdrücke `true` sind   |
| &&       | Und mit verkürzter Auswertung: Wie &, jedoch wird sofort `false` zurückgegeben, wenn der erste Ausdruck `false` ist |
| \|\|     | Oder mit verkürzter Auswertung: Wie \|, jedoch wird sofort `true` zurückgegeben, wenn der erste Ausdruck `true` ist  |
| \^       | Exklusives Oder: Liefert nur `true`, wenn genau einer der beiden Ausdrücke `true` ist             |

**if/else Anweisungen**

Die `else`-Anweisung erweitert die Kontrollstruktur von `if`, um einen Zweig hinzuzufügen, der ausgeführt wird, wenn die Bedingung der `if`-Anweisung nicht erfüllt ist. Die `else`-Anweisung hat die folgende Syntax:

```java
if (Bedingung) {
    // Wenn die Bedingung `true` ist
    Anweisung;
} else {
    // Wenn die Bedingung `false` ist
    Alternative_Anweisung;
}
```

Wenn die Bedingung der `if`-Anweisung wahr ist, werden die Anweisungen innerhalb des `if`-Blocks ausgeführt. Andernfalls werden die Anweisungen innerhalb des `else`-Blocks ausgeführt.

Die `else`-Anweisung ist optional und kann allein oder in Kombination mit einer `if`-Anweisung verwendet werden, um alternative Aktionen basierend auf Bedingungen auszuführen.

Beispiel:

```java
if ( bestimmeSemester() == 1 ) {
  System.out.println("Ihr Fach ist PRO1");
} else {
  System.out.println("Ihr Fach ist PRO2");
}
```

Die `else`-Anweisung kann auch mit verschachtelten `if`-Anweisungen verwendet werden, um komplexere Entscheidungsstrukturen zu erstellen.

```
if ( Bedingung 1 ){   
    Anweisung1;
} else {    
    if ( Bedingung 2 ){        
        Anweisung2;    
    } else {        
        Anweisung3;    
    }
}      
```

Enthält der `else`-Zweig lediglich ein weiteres if (ggf. mit else), können die Anweisungen auch fortgesetzt werden:

```
if ( Bedingung 1 ) {
        Anweisung1;
    } else if ( Bedingung 2 ){ 
        Anweisung2;
    } else if ( Bedingung 3 ){   		
        Anweisung3;
    } else {    
        Anweisung4;
    }
```

**Der bedingte Ausdruck**

- Der bedingte Ausdruck ist keine Anweisung sondern ein Operatorausdruck, also etwas, das in einem Ausdruck (z.B. einer Formel) eingesetzt werden kann. Vergleichbar mit der WENN( ; ; ) Formel in Excel: (Bedingung) ? Ausdruck1 : Ausdruck2
 
- Wenn die Bedingung wahr ist, so ist der Wert des Ausdrucks identisch mit Ausdruck1, sonst mit Ausdruck2
Beide Ausdrücke müssen vom selben Werttyp (int, char, String, etc.) sein

Beispiel:

```
int urlaubstage = (alter > 28 ? 30 : 25);
```

**switch/case**

Die switch-Anweisung bietet eine alternative Methode zur Kontrollstruktur if, insbesondere wenn eine Variable auf verschiedene Werte geprüft werden soll und abhängig vom Wert unterschiedliche Aktionen ausgeführt werden sollen.

Die Syntax einer `switch`-Anweisung sieht folgendermaßen aus:
![](switchcase.JPG)

- Der switch-Ausdruck muss Ergebnisse vom Typ byte, short, int, char, String oder Enumeration zurückliefern
- Im case-Teil müssen Konstanten stehen (keine Variablen, Funktionsaufrufe o.ä.)
- Die Konstanten im case-Teil müssen vom gleichen Typ wie der switch-Ausdruck sein (also auch byte, short, int, char oder String)
- Kein Wert der Konstanten dieser case-Zweige darf doppelt auftreten. Die Reihenfolge ist egal.
- Nach dem case kommt eine Folge von Anweisungen; üblicherweise abgeschlossen durch ein return oder break
- break ist optional – wenn es fehlt, wird die Bearbeitung mit dem nächsten case (ohne Prüfung!) fortgesetzt – aber Vorsicht: Fehler durch vergessene break sind schwierig zu finden.
- der default-Zweig ist optional; es ist höchstens einer zulässig



### Zählschleife ("normale for-Schleife")
Die Schleife wird von einer Anfangszahl bis zu einer Endzahl mit einer vorgegebenen Schrittweite wiederholt.

```java
class Demo{
    public static void main(String args[]){
        for (int i = 0; i < 10; i++){
          System.out.println(i);
        }
    }
}
```
@LIA.java(Demo)

**Anmerkungen**

- Eine im Schleifenkopf deklarierte Variable ist nur innerhalb der Schleife sichtbar.
- `break` verlässt die Schleife
- `continue` springt zum Ende der Schleife
- Teile des Kopfes können leer bleiben (z.B. stellt for(;;) eine Endlosschleife dar).

**Weiteres Beispiel**

```java
class Demo{
    public static void main(String args[]){
        int n = 4;
        int fakultaet = 1;
        for(int i = 1; i<=n; i++) {
            fakultaet *= i;
        }
        System.out.println(n + "! ? " + fakultaet);
    }
}
```
### For-Each-Schleife

Schleife führt den Rumpf für jedes Element der Menge aus

```java
class Demo{
    public static void main(String args[]){
        String[] f = {"eins", "zwei", "drei"}; //Dies ist ein Array und wird im nächsten Kapitel erklärt
        for(String s : f) {
            System.out.println(s);
        }
    }
}
```
@LIA.java(Demo)
### while-Schleife
Die while-Schleife wird verwendet, um einen Codeblock wiederholt auszuführen, solange eine bestimmte Bedingung erfüllt ist. Die Bedingung wird vor jeder Ausführung des Codeblocks überprüft.

```java
class Demo{
    public static void main(String args[]){
        int count = 0;
        while (count < 5) {
            System.out.println(count);
            count++;
        }
    }
}
```
@LIA.java(Demo)

**Anmerkungen**

- Die Bedingung der `while`-Schleife wird vor der Ausführung des Codeblocks überprüft. Wenn die Bedingung falsch ist, wird der Codeblock nicht ausgeführt und die Schleife wird beendet.
- Es ist wichtig, sicherzustellen, dass sich die Bedingung im Verlauf der Schleife ändert, um eine Endlosschleife zu vermeiden.
- `break` kann verwendet werden, um die Schleife vorzeitig zu beenden, und `continue` springt zum nächsten Schleifendurchlauf.

Die `while`-Schleife ist besonders nützlich, wenn die Anzahl der Iterationen im Voraus nicht bekannt ist, sondern von einer Bedingung abhängt.

### Abschluss und Aufgaben

Führen Sie die Aufgaben aus der Aufgabendatenkbank Kapitel 2 durch. Hierfür benötigen Sie den `Scanner`:

Vor der Klassendeklaration importieren Sie  `java.util.Scanner`. In der Hauptmethode verwenden Sie folgende Befehle:

```
Scanner scanner = new Scanner(System.in);
System.out.println("Bitte geben Sie an, wie viele Primzahlen
berechnet werden sollen: ");
int n = scanner.nextInt();
```

TODO (MB): Aufgaben in Datenbank stellen

**Aufgabe 1:**  pinCodeGenerator (im Ordner schleifen)

**Aufgabe 2:**  maximum (im Ordner verzweigungen)

**Aufgabe 3:**  switch-case (im Ordner verzweigungen)



## Arrays

Schauen Sie sich folgenden Code an: 
- Was passiert hier?
- Welches Anwendungsszenario könnte hier wiedergegeben sein?
- Worin bestehen die Vor- und Nachteile in diesem Code?


```java
import java.io.*;

class Demo{
    public static void main(String args[]){
        int wpmMo = 55;
        int wpmDi = 57;
        int wpmMi = 49;
        int wpmDo = 63;
        int wpmFr = 0;
        int wpmSa = 56;
        int wpmSo = 70;

        int sum = 0;
        sum += wpmMo;
        sum += wpmDi;
        sum += wpmMi;
        sum += wpmDo;
        sum += wpmFr;
        sum += wpmSa;
        sum += wpmSo;

        int avg = sum / 7;
        System.out.println(avg);
    }
}
```
@LIA.java(Demo)

Ein mögliches Anwendungsszenario könnte sein:

Sie haben gemessen, wie schnell Sie Java-Code tippen können und sind dabei wie folgt vorgegangen:

- Täglich üben und `wpm` messen
- Wert in einer Variable für diesen Tag eintragen
- Summe über alle Tages-Variablen bilden
- Durchschnitt berechnen

Das ist ziemlich repetetiv, denn neben der vielen Tipparbeit ist das auch noch:

- Fehleranfällig: einen Tag vergessen, einen Tag doppelt nehmen
- Unflexibel: was ist, wenn wir länger als exakt eine Woche üben?

Für sich wiederholende Berechnungen haben wir bereits die Schleife kennengelernt. Dabei konnten wir z.B. einen Zähler hochzählen:

```java
class Demo{
    public static void main(String args[]){
        int zaehler = 0;
        while(zaehler < 7) {
            System.out.println(zaehler);
            zaehler++;
        }
    }
}
```
@LIA.java(Demo)

Mit Arrays gibt es eine Datenstruktur, wo wir mit Hilfe eines solchen Zählers auf verschiedene Variablen zugreifen können. Statt einzelne Variablen für jeden Tag anzulegen speichern wie die `wpm` in einem Arrays:

```
int[] wpm = {55, 57, 49, 63, 0, 56, 70};
```

Im Speicher wird Platz für 7 direkt hintereinanderliegende int-Werte reserviert und befüllt:

TODO: Die Tabelle sieht doof aus


| Index | 0 | 1 | 2 | 3 | 4 | 5 | 6 |
|-------|---|---|---|---|---|---|---|
| Wert  | 55| 57| 49| 63| 0 | 56| 70|

Mit Hilfe des Index können wir auf die Werte zugreifen:

```
// Der Wert für Montag ist der erste Wert - wir fangen immer bei 0 an zu zählen
wpm[0];
```

Variablen vom Array-Typ haben eine  `.length`-Eigenschaft, die angibt wie viele Werte vorhanden sind:
```wpm.length```

Nun können wir eine Schleife verwenden, um den Mittelwert zu bilden:

```java
class Demo{
    public static void main(String args[]){
        int i = 0;
        int sum = 0;
        int[] wpm = {55, 57, 49, 63, 0, 56, 70};
            while(i < wpm.length) { // < statt <= weil wir bei 0 anfangen zu zählen
                sum += wpm[i];
                i++;
            }
        int avg = sum / wpm.length; // Durch Verwendung von .length statt 7 sind wir flexibel
        System.out.println("Der Durchschnitt ist: " + avg);
    }
}
```
@LIA.java(Demo)

### Arrays: Basics

Der Datentyp eines Arrays ergibt sich aus dem Basisdatentyp (der Datentyp jedes einzelnen Elements) mit angehängten eckigen Klammern `[]`, also z.B.
`int[], double[], boolean[], char[]`.

Arrays müssen immer initialisiert werden, sonst passiert sowas:

```java
class Demo{
    public static void main(String args[]){
        int[] meinArray;
        System.out.println(meinArray);
    }
}
```
@LIA.java(Demo)

Initialisieren können wir entweder mit Werten/Literalen, wie oben bei `wpm` oder z.B.:

```
char message[] = {'H', 'a', 'l', 'l', 'o'};
```

Oder per Schlüsselwort `new` - hier wird Speicher reserviert aber keine Werte hinterlegt:

```
double[] tagesTemperaturen2022 = new double[365];
```

Die Größe lässt sich nicht nachträglich nicht mehr ändern (hier 365)

<br>

Auf einzelne Werte wird per Zahl zugegriffen:

```
message[1] //wäre in dem Fall der Buchstabe a
```

Eine einzelne Position im Array verhält sich wie eine Variable - letztendlich lässt sich über die Adresse des Arrays, den Index und die Größe jedes Elements ja auch die Speicheradresse ermitteln. Somit kann ein Arrayzugriff auch links vom Zuweisungsoperator `=` stehen:

```
tagesTemperaturen2022[30] = 8.5;
```

Die Anzahl der Element im Array `a` ergibt sich mit `a.length`. Niemals nehmen wir ein Literal mit der aktuellen Länge! Das erste Element befindet sicht immer an Position 0. Somit ist das letzte Element an Position `length - 1`:

```
message[message.length - 1]
```

Wie gerade (und oben schon) gesehen, kann die Position im Array (der *Index*) nicht nur als Literal, sondern als beliebiger `int`-Ausdruck angegeben werden:

```
System.out.println("Den wie vielten Buchstaben?");
char buchstabe = message[readInt() - 1]; // Der Computer zählt ab 0, der Mensch meist ab 1
System.out.println(buchstabe);
```

Es gibt verschiedene Möglichkeiten, Arrays auszugeben. Eine davon, die Ihnen bereits bekannt ist, ist diese

```
int [] liste = {0, 1, 2};		
System.out.println(liste[0]);	
System.out.println(liste[1]);	
System.out.println(liste[2]);
```
Diese Methode ist jedoch nicht besonders effizient. Daher verwenden wir Schleifen, um die Effizienz zu verbessern:

```
int zaehler = 0;
while (zaehler < 3) {
    zaehler++;
}
```

Durch die Kombination des Arrays mit einer Schleife erhalten wir dann folgende Ausgabe:

```
int [] liste = {0, 1, 2};
int zaehler = 0;
while (zaehler < 3) {
    System.out.println(liste[zaehler]);
    zaehler++;
}
```
### Mehrdimensionale Arrays

Arrays können auch mit mehrdimensionalen Indizes gebaut werden - in Java sind das technisch gesehen Arrays mit einem weiteren Array als Basisdatentyp. Beispiele für Anwendungen:
- Tabellen, z.B. Stundenplan mit Tagen als Spalten und Vorlesungsblöcken als Zeilen und Vorlesungsbezeichnung
- Bilder - 2 dimensionale Anordnungen von Pixel (Farbwerten)
- Welten in Computerspielen: zwei- oder dreidimensionale Anordnungen von Feldern

Durchwandern können wir diese Arrays mit geschachtelten Schleifen.

Ein zweidimensionales Array kann auch wieder per Literale oder per `new` konstruiert werden, z.B.:

```
// 5x5 Array mit true (Schwarz) / false (Weiss) Werten
boolean[][] schwarzweissBild = {{false, false, true, false, false}, 
                                {false, true, false, true, false},
                                {true, true, true, true, true},
                                {true, false, false, false, true},
                                {true, true, true, true, true}};

// Array für Klausurpunkte
int nStudierende = 30;
int nAufgaben = 10;
int[][] punkte = new int[nStudierende][nAufgaben];
```

### Übungen

TODO (MB): Aufgaben in Aufgabendatenbank

- 1. array-und-schleife
- 2. bubblesort
- 3. geschachtelte-arrays-for


## Strings


## Klassen, Objekte, Methoden
## Vererbung
## Abstrakte Klassen, Interfaces
## Collections & Maps
## Exceptions
## Generics (optional)
